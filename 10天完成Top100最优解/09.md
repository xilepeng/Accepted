

## [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func isPalindrome(head *ListNode) bool {
	slice := []int{}
	for ; head != nil; head = head.Next {
		slice = append(slice, head.Val)
	}
	for i, j := 0, len(slice)-1; i < j; {
		if slice[i] != slice[j] {
			return false
		}
		i++
		j--
	}
	return true
}
```



## [169. 多数元素](https://leetcode.cn/problems/majority-element/)


```go
func majorityElement(nums []int) int {
	res, count := -1, 0
	for _, num := range nums {
		if count == 0 { // 如果票数等于0，重新赋值，抵消掉非众数
			res = num
		}
		if res == num { // 如果num和众数res相等,票数自增1
			count++
		} else { // 不相等,票数自减1
			count--
		}
	}
	return res
}
```

```go
func moreThanHalfNum_Solution(nums []int) int {
    major, vote := -1, 0
    for _, x := range nums {
        if vote == 0 {
            major = x 
        }
        if major == x {
            vote++
        } else {
            vote--
        }
    }
    return major
}
```


## [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

```go
func findLength(nums1 []int, nums2 []int) (res int) {
	m, n := len(nums1), len(nums2)
	dp := make([][]int, m+1)
	for i := 0; i < m+1; i++ {
		dp[i] = make([]int, n+1)
	}
	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if nums1[i-1] == nums2[j-1] {
				dp[i][j] = dp[i-1][j-1] + 1
			}
			if res < dp[i][j] {
				res = dp[i][j]
			}
		}
	}
	return
}
```

```go
func findLength(nums1 []int, nums2 []int) (res int) {
	m, n := len(nums1), len(nums2)
	dp := make([]int, m+1)
	for i := 1; i <= m; i++ {
		for j := n; j >= 1; j-- {
			if nums1[i-1] == nums2[j-1] {
				dp[j] = dp[j-1] + 1
			} else {
				dp[j] = 0
			}
			if res < dp[j] {
				res = dp[j]
			}
		}
	}
	return
}
```




