


1. [94. 二叉树的中序遍历](#94-二叉树的中序遍历)
2. [704. 二分查找](#704-二分查找)
3. [232. 用栈实现队列](#232-用栈实现队列)
4. [199. 二叉树的右视图](#199-二叉树的右视图)
5. [70. 爬楼梯](#70-爬楼梯)
6. [19. 删除链表的倒数第 N 个结点](#19-删除链表的倒数第-n-个结点)
7. [148. 排序链表](#148-排序链表)
8. [4. 寻找两个正序数组的中位数](#4-寻找两个正序数组的中位数)
9. [56. 合并区间](#56-合并区间)
10. [69. x 的平方根](#69-x-的平方根)




##[124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxPathSum(root *TreeNode) int {
	maxSum := math.MinInt64
	var dfs func(*TreeNode) int
	dfs = func(node *TreeNode) int {
		if node == nil {
			return 0
		}
		left, right := max(dfs(node.Left), 0), max(dfs(node.Right), 0) // 左/右子树提供的最大路径和
		maxSum = max(maxSum, node.Val+left+right)                      // 当前子树内部的最大路径和更新最大路径和
		return node.Val + max(left, right)                             // 返回当前节点的最大路径和
	}
	dfs(root)
	return maxSum
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

[参考1](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/er-cha-shu-zhong-de-zui-da-lu-jing-he-by-leetcode-/)


[参考2](https://leetcode.cn/problems/binary-tree-maximum-path-sum/solution/shou-hui-tu-jie-hen-you-ya-de-yi-dao-dfsti-by-hyj8/)


## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) (res []int) {
	var dfs func(*TreeNode)
	dfs = func(root *TreeNode) {
		if root != nil {
			dfs(root.Left)
			res = append(res, root.Val)
			dfs(root.Right)
		}
	}
	dfs(root)
	return
}
```




## [704. 二分查找](https://leetcode-cn.com/problems/binary-search/) 


```go
func search(nums []int, target int) int {
	l, r := 0, len(nums)-1
	for l <= r {
		mid := l + (r-l)>>1
		if nums[mid] == target {
			return mid
		} else if nums[mid] < target {
			l = mid + 1
		} else {
			r = mid - 1
		}
	}
	return -1
}
```

## [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)


```go
/*
 * @lc app=leetcode.cn id=232 lang=golang
 *
 * [232] 用栈实现队列
 */

// @lc code=start
type MyQueue struct {
	inStack, outStack []int
}

func Constructor() MyQueue {
	return MyQueue{}
}

func (q *MyQueue) Push(x int) {
	q.inStack = append(q.inStack, x)
}

func (q *MyQueue) in2out() {
	for len(q.inStack) > 0 {
		q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])
		q.inStack = q.inStack[:len(q.inStack)-1]
	}
}

func (q *MyQueue) Pop() int {
	if len(q.outStack) == 0 {
		q.in2out()
	}
	x := q.outStack[len(q.outStack)-1]
	q.outStack = q.outStack[:len(q.outStack)-1]
	return x
}

func (q *MyQueue) Peek() int {
	if len(q.outStack) == 0 {
		q.in2out()
	}
	return q.outStack[0]
}

func (q *MyQueue) Empty() bool {
	return len(q.inStack) == 0 && len(q.outStack) == 0
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * param_2 := obj.Pop();
 * param_3 := obj.Peek();
 * param_4 := obj.Empty();
 */
// @lc code=end


```







## [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)



```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func rightSideView(root *TreeNode) (res []int) {
	var dfs func(*TreeNode, int)
	dfs = func(node *TreeNode, level int) { // 根右左
		if node == nil {
			return
		}
		if level == len(res) { // 如果不存在对应深度的节点
			res = append(res, node.Val)
		}
		dfs(node.Right, level+1)
		dfs(node.Left, level+1)
	}
	dfs(root, 0)
	return
}
```




## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

**方法一：滚动数组**

```go
func climbStairs(n int) int {
	p, q, r := 0, 0, 1
	for i := 1; i <= n; i++ {
		p = q
		q = r
		r = p + q
	}
	return r
}
```

**方法二：动态规划**

```go
func climbStairs(n int) int {
	dp := make([]int, n+1)
	dp[0], dp[1] = 1, 1
	for i := 2; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}
	return dp[n]
}
```

**压缩空间，优化**

dp[i] 只与过去的两项：dp[i-1] 和 dp[i-2] 有关，没有必要存下所有计算过的 dp 项。用两个变量去存这两个过去的状态就好。

```go
func climbStairs(n int) int {
	prev, curr := 0, 1
	for i := 1; i <= n; i++ {
		next := prev + curr
		prev = curr
		curr = next
	}
	return curr
}
```


## [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

**方法一：双指针**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummy := &ListNode{0, head}
	first, second := head, dummy
	for i := 0; i < n; i++ {
		first = first.Next
	}
	for ; first != nil; first = first.Next {
		second = second.Next
	}
	second.Next = second.Next.Next
	return dummy.Next
}
```
**优化**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummy := &ListNode{0, head}
	first, second := head, dummy
	for i := 0; first != nil; i++ {
		if i >= n {
			second = second.Next
		}
		first = first.Next
	}
	second.Next = second.Next.Next
	return dummy.Next
}
```

**方法二：计算链表长度**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummy := &ListNode{Next: head}
	prev, length := dummy, 0
	for ; head != nil; head = head.Next {
		length++
	}
	for i := 0; i < length-n; i++ {
		prev = prev.Next
	}
	prev.Next = prev.Next.Next
	return dummy.Next
}
```


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummy := &ListNode{Next: head}
	prev := dummy
	length := getLength(head)
	for i := 0; i < length-n; i++ {
		prev = prev.Next
	}
	prev.Next = prev.Next.Next
	return dummy.Next
}
func getLength(head *ListNode) (length int) {
	for ; head != nil; head = head.Next {
		length++
	}
	return
}
```



## [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)



```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func sortList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	slow, fast, preSlow := head, head, new(ListNode)
	for fast != nil && fast.Next != nil {
		preSlow = slow
		slow, fast = slow.Next, fast.Next.Next
	}
	preSlow.Next = nil
	left, right := sortList(head), sortList(slow)
	return merge2list(left, right)
}
func merge2list(l1, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}
	if l1.Val < l2.Val {
		l1.Next = merge2list(l1.Next, l2)
		return l1
	} else {
		l2.Next = merge2list(l1, l2.Next)
		return l2
	}
}
```


## [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)




## [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)



## [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)