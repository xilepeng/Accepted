

1. [72. 编辑距离](#72-编辑距离)
2. [69. x 的平方根](#69-x-的平方根)
3. [2. 两数相加](#2-两数相加)
4. [82. 删除排序链表中的重复元素 II](#82-删除排序链表中的重复元素-ii)
5. [31. 下一个排列](#31-下一个排列)
6. [剑指 Offer 22. 链表中倒数第k个节点](#剑指-offer-22-链表中倒数第k个节点)
7. [22. 括号生成](#22-括号生成)
8. [8. 字符串转换整数 (atoi)](#8-字符串转换整数-atoi)
9. [1143. 最长公共子序列](#1143-最长公共子序列)
10. [41. 缺失的第一个正数](#41-缺失的第一个正数)


## [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/) 

```go

```

## [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

**方法一：二分查找**

```go
func mySqrt(x int) int {
    l, r, res := 0, x, 0
    for l <= r {
        mid := l + (r-l)>>1
        if mid*mid <= x {
            res = mid
            l = mid + 1
        } else {
            r = mid - 1
        }
    }
    return res
}
```
复杂度分析

- 时间复杂度：O(logx)，即为二分查找需要的次数。
- 空间复杂度：O(1)。






## [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	dummy := new(ListNode)
	curr,carry := dummy, 0
	for l1 != nil || l2 != nil || carry > 0 {
		curr.Next = new(ListNode) // 新建一个节点存储计算结果
		curr = curr.Next // 将计算结果连接成链表
		if l1 != nil {
			carry += l1.Val
			l1 = l1.Next
		}
		if l2 != nil {
			carry += l2.Val
			l2 = l2.Next
		}
		curr.Val = carry % 10
		carry /= 10
	}
	return dummy.Next
}
```



## [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)


![](images/82.png)


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func deleteDuplicates(head *ListNode) *ListNode {
	dummy := &ListNode{0, head}
	prev := dummy
	for prev.Next != nil && prev.Next.Next != nil {
		if prev.Next.Val == prev.Next.Next.Val {
			x := prev.Next.Val // 记录重复元素
			for prev.Next != nil && prev.Next.Val == x {
				prev.Next = prev.Next.Next // 删除重复元素
			}
		} else {
			prev = prev.Next
		}
	}
	return dummy.Next
}
```



## [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

```go
func nextPermutation(nums []int) {
	i := len(nums) - 2                   // 向左遍历，i从倒数第二开始是为了nums[i+1]要存在
	for i >= 0 && nums[i] >= nums[i+1] { // 寻找第一个小于右邻居的数
		i--
	}
	if i >= 0 { // 这个数在数组中存在，从它身后挑一个数，和它换
		j := len(nums) - 1                 // 从最后一项，向左遍历
		for j >= 0 && nums[j] <= nums[i] { // 寻找第一个大于 nums[i] 的数
			j--
		}
		nums[i], nums[j] = nums[j], nums[i] // 两数交换，实现变大
	}
	// 如果 i = -1，说明是递减排列，如 3 2 1，没有下一排列，直接翻转为最小排列：1 2 3
	l, r := i+1, len(nums)-1
	for l < r { // i 右边的数进行翻转，使得变大的幅度小一些
		nums[l], nums[r] = nums[r], nums[l]
		l++
		r--
	}
}
```


## [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getKthFromEnd(head *ListNode, k int) *ListNode {
    slow, fast := head, head
    for i := 0; fast != nil; i++ {
        if i >= k {
            slow = slow.Next
        }
        fast = fast.Next
    }
    return slow
}
```


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getKthFromEnd(head *ListNode, k int) *ListNode {
    slow, fast := head, head
    for ; fast != nil && k > 0; k-- {
        fast = fast.Next
    }
    for fast != nil {
        slow = slow.Next
        fast = fast.Next
    }
    return slow
}
```




## [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)



## [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/) 


## [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

## [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)