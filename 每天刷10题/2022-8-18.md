
<!-- [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)


[165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)


[78. 子集](https://leetcode-cn.com/problems/subsets/)


[43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)

[32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

[543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)


[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) -->

[129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func sumNumbers(root *TreeNode) int {
	return dfs(root, 0)
}
func dfs(root *TreeNode, prevSum int) int {
	if root == nil {
		return 0
	}
	sum := prevSum*10 + root.Val
	if root.Left == nil && root.Right == nil {
		return sum
	}
	return dfs(root.Left, sum) + dfs(root.Right, sum)
}
```


[43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)

![](images/43.png)

```go
func multiply(num1 string, num2 string) string {
	if num1 == "0" || num2 == "0" {
		return "0"
	}
	m, n := len(num1), len(num2)
	A := make([]int, m+n)
	for i := m - 1; i >= 0; i-- {
		x := int(num1[i] - '0')
		for j := n - 1; j >= 0; j-- {
			y := int(num2[j] - '0')
			A[i+j+1] += x * y // 竖式乘法，只累加但不进位
		}
	}
	for i := m + n - 1; i > 0; i-- {
		A[i-1] += A[i] / 10 // 进位
		A[i] %= 10          // 个位
	}
	res, i := "", 0
	if A[0] == 0 { // 去除前导0
		i = 1
	}
	for ; i < m+n; i++ {
		res += strconv.Itoa(A[i]) //整数转字符串、拼接
	}
	return res
}
```

[参考视频](https://www.bilibili.com/video/BV1ba4y1J7yh)

[165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)


```go
func compareVersion(version1 string, version2 string) int {
	i, j, m, n := 0, 0, len(version1), len(version2)
	for i < m || j < n {
		x := 0
		for ; i < m && version1[i] != '.'; i++ {
			x = x*10 + int(version1[i]-'0')
		}
		i++ // 跳过点号
		y := 0
		for ; j < n && version2[j] != '.'; j++ {
			y = y*10 + int(version2[j]-'0')
		}
		j++ // 跳过点号
		if x > y {
			return 1
		}
		if x < y {
			return -1
		}
	}
	return 0
}
```

[78. 子集](https://leetcode-cn.com/problems/subsets/)

```go
func subsets(nums []int) (res [][]int) {
	n := len(nums)
	for mask := 0; mask < 1<<n; mask++ { // mask 从 000 到 111
		set := []int{}
		for i, v := range nums {
			if mask>>i&1 == 1 { // mask 的第 i 位是否为1
				set = append(set, v)
			}
		}
		res = append(res, set)
	}
	return
}
```

```go
func subsets(nums []int) [][]int {
	res, set := [][]int{}, []int{}
	var dfs func(int)

	dfs = func(i int) {
		if i == len(nums) { // 指针越界
			res = append(res, append([]int(nil), set...)) // 加入解集
			return                                        // 结束当前的递归
		}
		set = append(set, nums[i]) //选择这个数
		dfs(i + 1)                 // 基于该选择，继续往下递归，考察下一个数
		set = set[:len(set)-1]     // 上面的递归结束，撤销该选择
		dfs(i + 1)                 // 不选这个数，继续往下递归，考察下一个数
	}

	dfs(0)
	return res
}
```

```go
func subsets(nums []int) [][]int {
	res, set := [][]int{}, []int{}
	var dfs func(int)

	dfs = func(i int) {
		res = append(res, append([]int(nil), set...)) // 调用子递归前，加入解集
		for j := i; j < len(nums); j++ {              // 枚举出所有可选的数
			set = append(set, nums[j]) // 选这个数
			dfs(j + 1)                 // 基于选这个数，继续递归，传入的j+1，不是i+1
			set = set[:len(set)-1]     // 撤销选这个数
		}
	}

	dfs(0)
	return res
}
```


[32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

```go

```

[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

```go

```

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

```go

```

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```go

```

[543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

```go

```

[64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)


```go

```
