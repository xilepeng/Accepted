
1. [160. 相交链表](#160-相交链表)
2. [46. 全排列](#46-全排列)
3. [47. 全排列 II  补充](#47-全排列-ii--补充)
4. [54. 螺旋矩阵](#54-螺旋矩阵)
5. [23. 合并K个升序链表](#23-合并k个升序链表)
6. [142. 环形链表 II](#142-环形链表-ii)
7. [92. 反转链表 II](#92-反转链表-ii)
8. [415. 字符串相加](#415-字符串相加)
9. [300. 最长递增子序列](#300-最长递增子序列)
10. [42. 接雨水](#42-接雨水)
11. [143. 重排链表](#143-重排链表)

---


## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	if headA == nil || headB == nil {
		return nil
	}
	A, B := headA, headB
	for A != B {
		if A != nil {
			A = A.Next
		} else {
			A = headB
		}
		if B != nil {
			B = B.Next
		} else {
			B = headA
		}
	}
	return A
}
```

## [46. 全排列](https://leetcode-cn.com/problems/permutations/)

```go
func permute(nums []int) (res [][]int) {
	n := len(nums)
	var dfs func(int)
	dfs = func(first int) {
		if first == n { // 所有数都填完了
			res = append(res, append([]int{}, nums...))
		}
		for i := first; i < n; i++ {
			nums[first], nums[i] = nums[i], nums[first] // 动态维护数组
			dfs(first + 1)                              // 继续递归填下一个数
			nums[first], nums[i] = nums[i], nums[first] // 撤销操作
		}
	}
	dfs(0)
	return
}
```

```go
func permute(nums []int) (res [][]int) {
	used, path, n := make(map[int]bool, len(nums)), []int{}, len(nums)
	var dfs func(int)
	dfs = func(pos int) {
		for i := 0; i < n; i++ {
			if len(path) == n {
				res = append(res, append([]int{}, path...))
				return
			}
			if !used[i] {
				used[i] = true
				path = append(path, nums[i])
				dfs(pos + 1)
				path = path[:len(path)-1]
				used[i] = false
			}
		}
	}
	dfs(0)
	return
}
```

## [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)  补充




## [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

**方法一：遍历到底**

```go
func spiralOrder(matrix [][]int) (res []int) {
    if len(matrix) == 0 { return []int{} }
    top, right, bottom, left := 0, len(matrix[0])-1, len(matrix)-1, 0
    length := len(matrix)*len(matrix[0])
    for len(res) != length {
        for i := left; i <= right; i++ {res = append(res, matrix[top][i])}
        top ++
        for i := top; i <= bottom; i++ {res = append(res, matrix[i][right])}
        right --
        if len(res) == length { break}
        for i := right; i >= left; i-- {res = append(res, matrix[bottom][i])}
        bottom --
        for i := bottom; i >= top; i-- {res = append(res, matrix[i][left])}
        left ++
    }
    return 
}
```

```go
func spiralOrder(matrix [][]int) (res []int) {
    if len(matrix) == 0 { return []int{}}
    top, right, bottom, left := 0, len(matrix[0])-1, len(matrix)-1, 0
    for left <= right && top <= bottom {
        for i := left; i <= right; i++ {res = append(res, matrix[top][i])}
        top ++
        for i := top; i <= bottom; i++ {res = append(res, matrix[i][right])}
        right --
        if left > right || top > bottom {break}  // 遍历完成要么发生在遍历完“上边”，要么发生在遍历完“右边”
        for i := right; i >= left; i-- {res = append(res, matrix[bottom][i])}
        bottom --
        for i := bottom; i >= top; i-- {res = append(res, matrix[i][left])}
        left ++
    }
    return
}
```
**方法二：遍历到最后一个前，不包含最后一个**

```go
func spiralOrder(matrix [][]int) (res []int) {
	if len(matrix) == 0 {
		return []int{}
	}
	top, right, bottom, left := 0, len(matrix[0])-1, len(matrix)-1, 0
	for top < bottom && left < right {
		for i := left; i < right; i++ {res = append(res, matrix[top][i]) }
		for i := top; i < bottom; i++ {res = append(res, matrix[i][right])}
		for i := right; i > left; i-- {res = append(res, matrix[bottom][i])}
		for i := bottom; i > top; i-- {res = append(res, matrix[i][left])}
		top++
		right--
		bottom--
		left++
	}
	if top == bottom {
		for i := left; i <= right; i++ {res = append(res, matrix[top][i]) }
	}else if left == right {
		for i := top; i <= bottom; i++ {res = append(res, matrix[i][right])}
	}
	return
}
```

## [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeKLists(lists []*ListNode) *ListNode {
	n := len(lists)
	if n == 0 {
		return nil
	}
	if n == 1 {
		return lists[0]
	}
	mid := n >> 1
	left, right := mergeKLists(lists[:mid]), mergeKLists(lists[mid:]) // 分
	return merge2List(left, right)                                    // 治
}
func merge2List(l1, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}
	if l1.Val < l2.Val {
		l1.Next = merge2List(l1.Next, l2)
		return l1
	} else {
		l2.Next = merge2List(l1, l2.Next)
		return l2
	}
}
```

## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
	slow, fast := head, head
	for fast != nil && fast.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
		if slow == fast {
			fast = head
			for slow != fast {
				slow, fast = slow.Next, fast.Next
			}
			return fast
		}
	}
	return nil
}
```


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
	slow, ok := hasCycle(head)
	if !ok {
		return nil
	}
	fast := head
	for slow != fast {
		slow = slow.Next
		fast = fast.Next
	}
	return fast
}
func hasCycle(head *ListNode) (*ListNode, bool) {
	slow, fast := head, head
	for fast != nil && fast.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
		if slow == fast {
			return slow, true
		}
	}
	return nil, false
}
```



## [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

**方法一：双指针**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseBetween(head *ListNode, left int, right int) *ListNode {
	dummy := &ListNode{Next: head}
	pre := dummy
	for i := 0; i < left-1; i++ {
		pre = pre.Next
	}
	prev, curr := pre.Next, pre.Next.Next
	for i := 0; i < right-left; i++ {
		next := curr.Next
		curr.Next = prev
		prev = curr
		curr = next
	}
	pre.Next.Next = curr
	pre.Next = prev
	return dummy.Next
}
```


**方法二：头插法**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseBetween(head *ListNode, left int, right int) *ListNode {
	dummy := &ListNode{Next: head}
	pre := dummy
	for i := 0; i < left-1; i++ {
		pre = pre.Next
	}
	curr := pre.Next
	for i := 0; i < right-left; i++ {
		next := curr.Next
		curr.Next = next.Next // 📝 
		next.Next = pre.Next
		pre.Next = next
	}
	return dummy.Next
}
```

**方法三：穿针引线**

```go

```

## [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)


```go
func addStrings(num1 string, num2 string) string {
	res, carry := "", 0
	for i, j := len(num1)-1, len(num2)-1; i >= 0 || j >= 0 || carry > 0; i, j = i-1, j-1 {
		var x, y int
		if i >= 0 {
			x = int(num1[i] - '0')
		}
		if j >= 0 {
			y = int(num2[j] - '0')
		}
		tmp := x + y + carry
		res = strconv.Itoa(tmp%10) + res
		carry = tmp / 10
	}
	return res
}
```


## [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```go
func lengthOfLIS(nums []int) int {
	dp := []int{} // 维护单调递增数组 sorted
	for _, x := range nums {
		// 在递增顺序的数组dp中搜索x，返回x的索引。如果查找不到，返回值是x应该插入dp的位置
		i := sort.SearchInts(dp, x) // min_index
		if i == len(dp) {           // dp 中不存在 x
			dp = append(dp, x)
		} else {
			dp[i] = x // dp 中存在 x，更新
		}
	}
	return len(dp)
}
```


## [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/) 

```go
func trap(height []int) (res int) {
	left, right := 0, len(height)-1
	leftMax, rightMax := 0, 0
	for left < right {
		leftMax = max(leftMax, height[left])
		rightMax = max(rightMax, height[right])
		if height[left] < height[right] {
			res += leftMax - height[left]
			left++
		} else {
			res += rightMax - height[right]
			right--
		}
	}
	return
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

## [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)


```go
 *
 * [143] 重排链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reorderList(head *ListNode) {
	if head == nil {
		return
	}
	mid := middleNode(head)
	l1, l2 := head, mid.Next
	mid.Next = nil
	l2 = reverse(l2)
	mergeList(l1, l2)
}
func middleNode(head *ListNode) *ListNode {
	slow, fast := head, head
	for fast.Next != nil && fast.Next.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
	}
	return slow
}
func reverse(head *ListNode) *ListNode {
	var prev *ListNode
	curr := head
	for curr != nil {
		next := curr.Next
		curr.Next = prev
		prev = curr
		curr = next
	}
	return prev
}
func mergeList(l1, l2 *ListNode) {
	var l1Tmp, l2Tmp *ListNode
	for l1 != nil && l2 != nil {
		l1Tmp, l2Tmp = l1.Next, l2.Next
		l1.Next = l2
		l1 = l1Tmp
		l2.Next = l1
		l2 = l2Tmp
	}
}
```