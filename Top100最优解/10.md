

1. [83. 删除排序链表中的重复元素](#83-删除排序链表中的重复元素)
2. [198. 打家劫舍](#198-打家劫舍)
3. [695. 岛屿的最大面积](#695-岛屿的最大面积)
4. [226. 翻转二叉树](#226-翻转二叉树)
5. [139. 单词拆分](#139-单词拆分)
6. [560. 和为 K 的子数组](#560-和为-k-的子数组)
7. [209. 长度最小的子数组](#209-长度最小的子数组)
8. [补充题6. 手撕堆排序 912. 排序数组](#补充题6-手撕堆排序-912-排序数组)
9. [24. 两两交换链表中的节点](#24-两两交换链表中的节点)
10. [297. 二叉树的序列化与反序列化](#297-二叉树的序列化与反序列化)



## [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func deleteDuplicates(head *ListNode) *ListNode {
	if head == nil {
		return head
	}
	curr := head
	for curr.Next != nil {
		if curr.Val == curr.Next.Val { // 如果当前当前节点值等于下一个节点值
			curr.Next = curr.Next.Next // 删除重复
		} else { // 无重复
			curr = curr.Next // 继续向后扫描
		}
	}
	return head
}
```

## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

```go
func rob(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	if n == 1 {
		return nums[0]
	}
	dp := make([]int, n)
	dp[0] = nums[0]               // 只有一间房屋，则偷窃该房屋
	dp[1] = max(nums[0], nums[1]) // 只有两间房屋，选择其中金额较高的房屋进行偷窃
	for i := 2; i < n; i++ {
		dp[i] = max(dp[i-2]+nums[i], dp[i-1]) // dp[i] 前i间房屋能偷窃到的最高总金额 = max(抢第i间房子，不抢第i件房子)
	}
	return dp[n-1]
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

```go
func rob(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	pre1, pre2 := 0, 0
	for i := 0; i < n; i++ {
		tmp := pre1
		pre1 = max(pre2+nums[i], pre1)
		pre2 = tmp
	}
	return pre1
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```


```go
func rob(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	preMax, curMax := 0, 0
	for i := 0; i < n; i++ {
		// preMax, curMax = curMax, max(preMax+nums[i], curMax)
		tmp := curMax
		curMax = max(preMax+nums[i], curMax)
		preMax = tmp
	}
	return curMax
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```


```go
// 解法三 模拟
func rob(nums []int) int {
	// a 对于偶数位上的最大值的记录
	// b 对于奇数位上的最大值的记录
	a, b := 0, 0
	for i := 0; i < len(nums); i++ {
		if i%2 == 0 {
			a = max(a+nums[i], b)
		} else {
			b = max(b+nums[i], a)
		}
	}
	return max(a, b)
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```


## [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

```go
func maxAreaOfIsland(grid [][]int) int {
	maxArea := 0
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			if grid[i][j] == 1 {
				maxArea = max(maxArea, dfs(grid, i, j))
			}
		}
	}
	return maxArea
}

func dfs(grid [][]int, i, j int) int {
	if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[0]) || grid[i][j] == 0 {
		return 0
	}
	area := 1      // 岛屿的面积至少为1
	grid[i][j] = 0 // 已扫描，标记为海洋，防止重复扫描
	area += dfs(grid, i-1, j)
	area += dfs(grid, i+1, j)
	area += dfs(grid, i, j-1)
	area += dfs(grid, i, j+1)
	return area
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```


## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return nil
	}
	invertTree(root.Left)                         // 翻转左子树
	invertTree(root.Right)                        // 翻转右子树 (入栈：压栈压到底部)
	root.Left, root.Right = root.Right, root.Left // 交换（出栈：自底向上）
	return root
}
```

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return nil
	}
	root.Left, root.Right = root.Right, root.Left // 交换左右子树
	invertTree(root.Left)                         // 翻转左子树
	invertTree(root.Right)                        // 翻转右子树 
	return root
}
```


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return nil
	}
	q := []*TreeNode{root}
	for len(q) > 0 {
		node := q[0]                                  // 取队首
		q = q[1:]                                     // 队首元素出队
		node.Left, node.Right = node.Right, node.Left // 翻转左右子树
		if node.Left != nil {
			q = append(q, node.Left)
		}
		if node.Right != nil {
			q = append(q, node.Right)
		}
	}
	return root
}
```





## [139. 单词拆分](https://leetcode.cn/problems/word-break/)

## [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)



## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)



## [补充题6. 手撕堆排序 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```go
func sortArray(nums []int) []int {
	heapSort(nums)
	return nums
}

func heapSort(nums []int) {
	heapSize := len(nums)
	buildMaxHeap(nums, heapSize)
	for i := heapSize - 1; i >= 1; i-- {
		nums[0], nums[i] = nums[i], nums[0]
		heapSize--
		maxHeapify(nums, 0, heapSize)
	}
}

func buildMaxHeap(nums []int, heapSize int) {
	for i := heapSize >> 1; i >= 0; i-- {
		maxHeapify(nums, i, heapSize)
	}
}

func maxHeapify(nums []int, i, heapSize int) {
	for i<<1+1 < heapSize {
		lson, rson, large := i<<1+1, i<<1+2, i
		if lson < heapSize && nums[large] < nums[lson] {
			large = lson
		}
		for rson < heapSize && nums[large] < nums[rson] {
			large = rson
		}
		if large != i {
			nums[i], nums[large] = nums[large], nums[i]
			i = large
		} else {
			break
		}
	}
}

func maxHeapify1(nums []int, i, heapSize int) {
	lson, rson, large := i<<1+1, i<<1+2, i
	if lson < heapSize && nums[large] < nums[lson] {
		large = lson
	}
	if rson < heapSize && nums[large] < nums[rson] {
		large = rson
	}
	if large != i {
		nums[i], nums[large] = nums[large], nums[i]
		maxHeapify(nums, large, heapSize)
	}
}
```




## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
	dummy := &ListNode{Next: head}
	temp := dummy
	for temp.Next != nil && temp.Next.Next != nil {
		node1, node2 := temp.Next, temp.Next.Next
		temp.Next = node2       // 头插
		node1.Next = node2.Next // 连接后继
		node2.Next = node1      // 交换
		temp = node1            // 交换下一对
	}
	return dummy.Next
}

// 递归
func swapPairs1(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	newHead := head.Next
	head.Next = swapPairs(newHead.Next) // 将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。
	newHead.Next = head                 // 节点交换
	return newHead
}
```


[参考官方题解](https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/444474/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/)




## [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)
