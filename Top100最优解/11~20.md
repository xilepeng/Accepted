1. [5. 最长回文子串](#5-最长回文子串)
2. [102. 二叉树的层序遍历](#102-二叉树的层序遍历)
3. [33. 搜索旋转排序数组](#33-搜索旋转排序数组)
4. [200. 岛屿数量](#200-岛屿数量)
5. [141. 环形链表](#141-环形链表)
6. [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
7. [20. 有效的括号](#20-有效的括号)

## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```go
func longestPalindrome(s string) string {
	res, n := "", len(s)
	var extend func(int, int)

	extend = func(i, j int) {  // 中心扩展算法
		for i >= 0 && j < n && s[i] == s[j] {
			if len(res) < j-i+1 {
				res = s[i : j+1]
			}
			i-- // 扩展
			j++
		}
	}
	for i := 0; i < n; i++ {
		extend(i, i)   // 以自身为中心点
		extend(i, i+1) // 以自身和自身的下一个元素为中心点
	}
	return res
}
```

## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

**方法一：DFS递归**

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func levelOrder(root *TreeNode) (res [][]int) {
	var dfs func(*TreeNode, int)

	dfs = func(node *TreeNode, level int) {
		if node == nil {
			return
		}
		if len(res) == level { // 首次进入，加入空列表
			res = append(res, []int{})
		}
		res[level] = append(res[level], node.Val) // 将当前节点的值加入当前层
		dfs(node.Left, level+1)                   // 递归扫描下一层节点
		dfs(node.Right, level+1)
	}

	dfs(root, 0)
	return
}
```

**方法二：BFS(queue)迭代**

```go

/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) (res [][]int) {
	if root == nil {
		return
	}
	queue := []*TreeNode{root}                // 存储当前层节点到队列
	for level := 0; len(queue) > 0; level++ { // 队列不为空,遍历队列，检查下一层
		res = append(res, []int{})
		next := []*TreeNode{}
		for j := 0; j < len(queue); j++ { // 遍历当前层
			node := queue[j]
			res[level] = append(res[level], node.Val) // 存储当前层节点的值
			if node.Left != nil {                     // 遍历左子树，加入下一层队列
				next = append(next, node.Left)
			}
			if node.Right != nil { // 遍历右子树，加入下一层队列
				next = append(next, node.Right)
			}
		}
		queue = next // 扫描下一层
	}
	return
}
```

## [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```go
func search(nums []int, target int) int {
	l, r := 0, len(nums)-1
	for l <= r {
		mid := l + (r-l)>>1
		if nums[mid] == target {
			return mid
		}
		if nums[l] <= nums[mid] { // 左边有序
			if nums[l] <= target && target <= nums[mid] { // 答案在左边
				r = mid - 1
			} else {
				l = mid + 1
			}
		} else { // 右边有序
			if nums[mid] <= target && target <= nums[r] { // 答案在右边
				l = mid + 1
			} else {
				r = mid - 1
			}
		}
	}
	return -1
}
```

## [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

```go
func numIslands(grid [][]byte) int {
	count := 0
	for i := 0; i < len(grid); i++ { // 行
		for j := 0; j < len(grid[0]); j++ { // 列
			if grid[i][j] == '1' { // 如果找到岛屿
				count++         // 岛屿数量加1
				dfs(grid, i, j) // dfs标记此岛屿所有节点已遍历
			}
		}
	}
	return count
}

func dfs(grid [][]byte, i, j int) {
	if 0 <= i && i < len(grid) && 0 <= j && j < len(grid[0]) && grid[i][j] == '1' {
		grid[i][j] = '0'  // 标记此节点已遍历
		dfs(grid, i+1, j) //右（顺序无关）
		dfs(grid, i-1, j) //左
		dfs(grid, i, j+1) //上
		dfs(grid, i, j-1) //下
	}
}
```

## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
	slow, fast := head, head
	for fast != nil && fast.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next // 需提前判断不为 nil
		if slow == fast {
			return true
		}
	}
	return false
}
func hasCycle1(head *ListNode) bool {
	if head == nil || head.Next == nil {
		return false
	}
	slow, fast := head, head.Next
	for slow != fast {
		if fast == nil || fast.Next == nil {
			return false
		}
		slow = slow.Next
		fast = fast.Next.Next
	}
	return true
}
```

## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```go

```

## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```go

```
