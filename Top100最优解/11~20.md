1. [5. 最长回文子串](#5-最长回文子串)
2. [102. 二叉树的层序遍历](#102-二叉树的层序遍历)
3. [33. 搜索旋转排序数组](#33-搜索旋转排序数组)
4. [200. 岛屿数量](#200-岛屿数量)
5. [141. 环形链表](#141-环形链表)
6. [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
7. [20. 有效的括号](#20-有效的括号)

## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```go
func longestPalindrome(s string) string {
	res, n := "", len(s)
	var extend func(int, int)

	extend = func(i, j int) {  // 中心扩展算法
		for i >= 0 && j < n && s[i] == s[j] {
			if len(res) < j-i+1 {
				res = s[i : j+1]
			}
			i-- // 扩展
			j++
		}
	}
	for i := 0; i < n; i++ {
		extend(i, i)   // 以自身为中心点
		extend(i, i+1) // 以自身和自身的下一个元素为中心点
	}
	return res
}
```

## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

**方法一：DFS递归**

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func levelOrder(root *TreeNode) (res [][]int) {
	var dfs func(*TreeNode, int)

	dfs = func(node *TreeNode, level int) {
		if node == nil {
			return
		}
		if len(res) == level { // 首次进入，加入空列表
			res = append(res, []int{})
		}
		res[level] = append(res[level], node.Val) // 将当前节点的值加入当前层
		dfs(node.Left, level+1)                   // 递归扫描下一层节点
		dfs(node.Right, level+1)
	}

	dfs(root, 0)
	return
}
```

**方法二：BFS(queue)迭代**

```go

/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) (res [][]int) {
	if root == nil {
		return
	}
	queue := []*TreeNode{root}                // 存储当前层节点到队列
	for level := 0; len(queue) > 0; level++ { // 队列不为空,遍历队列，检查下一层
		res = append(res, []int{})
		next := []*TreeNode{}
		for j := 0; j < len(queue); j++ { // 遍历当前层
			node := queue[j]
			res[level] = append(res[level], node.Val) // 存储当前层节点的值
			if node.Left != nil {                     // 遍历左子树，加入下一层队列
				next = append(next, node.Left)
			}
			if node.Right != nil { // 遍历右子树，加入下一层队列
				next = append(next, node.Right)
			}
		}
		queue = next // 扫描下一层
	}
	return
}
```

## [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```go
func search(nums []int, target int) int {
	l, r := 0, len(nums)-1
	for l <= r {
		mid := l + (r-l)>>1
		if nums[mid] == target {
			return mid
		}
		if nums[l] <= nums[mid] { // 左边有序
			if nums[l] <= target && target <= nums[mid] { // 答案在左边
				r = mid - 1
			} else {
				l = mid + 1
			}
		} else { // 右边有序
			if nums[mid] <= target && target <= nums[r] { // 答案在右边
				l = mid + 1
			} else {
				r = mid - 1
			}
		}
	}
	return -1
}
```

## [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

```go

```

## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```go

```

## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```go

```

## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```go

```
