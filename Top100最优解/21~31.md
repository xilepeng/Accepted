
1. [141. 环形链表](#141-环形链表)
2. [88. 合并两个有序数组](#88-合并两个有序数组)
3. [103. 二叉树的锯齿形层序遍历](#103-二叉树的锯齿形层序遍历)
4. [236. 二叉树的最近公共祖先](#236-二叉树的最近公共祖先)




## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
	slow, fast := head, head
	for fast != nil && fast.Next != nil {
		fast = fast.Next.Next
		slow = slow.Next
		if slow == fast { // 指针相遇 => 有环
			return true
		}
	}
	return false
}
```

## [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
	for tail := m + n; m > 0 && n > 0; tail-- {
		if nums1[m-1] < nums2[n-1] {
			nums1[tail-1] = nums2[n-1]
			n--
		} else {
			nums1[tail-1] = nums1[m-1]
			m--
		}
	}
	for ; n > 0; n-- {
		nums1[n-1] = nums2[n-1]
	}
}


func merge(nums1 []int, m int, nums2 []int, n int) {
	i, j := m-1, n-1
	for tail := m + n - 1; tail >= 0; tail-- {
		if i < 0 || (j >= 0 && nums1[i] <= nums2[j]) {
			nums1[tail] = nums2[j]
			j--
		} else {
			nums1[tail] = nums1[i]
			i--
		}
	}
}

```

## [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)


```go

```

## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```go

```