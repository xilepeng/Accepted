

## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)


```go
func lengthOfLongestSubstring(s string) int {
	longest, n := 0, len(s)
	freq := make(map[byte]int, n)
	for i, j := 0, 0; j < n; j++ {
		freq[s[j]]++
		for freq[s[j]] > 1 {
			freq[s[i]]--
			i++
		}
		longest = max(longest, j-i+1) 
	}
	return longest
}
```

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) 

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
*/
// 方法一：迭代
func reverseList(head *ListNode) *ListNode {
	var prev *ListNode
	curr := head
	for curr != nil {
		temp := curr.Next
		curr.Next = prev
		prev = curr
		curr = temp
	}
	return prev
}

// 方法二：递归
func reverseList_2(head *ListNode) *ListNode {
	if head == nil || head.Next == nil { // 递归出口：没有节点或只有一个节点
		return head
	}
	newHead := reverseList(head.Next) // 子问题
	head.Next.Next = head             // 翻转
	head.Next = nil                   // 断开旧链
	return newHead
}

// 方法三：穿针引线
func reverseList_3(head *ListNode) *ListNode {
	dummy, curr := &ListNode{Next: head}, head
	for curr != nil && curr.Next != nil { // 至少有2个节点
		temp := curr.Next
		curr.Next = temp.Next
		temp.Next = dummy.Next // 如果等于 curr，将导致断开链表
		dummy.Next = temp
	}
	return dummy.Next
}
```




## [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)



```go
type LRUCache struct {
	cache          map[int]*DLinkedNode
	head, tail     *DLinkedNode
	capacity, size int
}

type DLinkedNode struct {
	key, value int
	prev, next *DLinkedNode
}

func InitDLinkedNode(key, value int) *DLinkedNode {
	return &DLinkedNode{
		key:   key,
		value: value,
	}
}

func Constructor(capacity int) LRUCache {
	l := LRUCache{
		cache:    map[int]*DLinkedNode{},// : 不是 :=
		head:     InitDLinkedNode(0, 0),
		tail:     InitDLinkedNode(0, 0),
		capacity: capacity,
	}
	l.head.next = l.tail
	l.tail.prev = l.head
	return l
}

func (this *LRUCache) Get(key int) int {
	if _, ok := this.cache[key]; !ok {
		return -1
	} else {
		node := this.cache[key]
		this.moveToHead(node)
		return node.value
	}
}

func (this *LRUCache) Put(key int, value int) {
	if _, ok := this.cache[key]; !ok {
		node := InitDLinkedNode(key, value)
		// 忘记将节点加入缓存了
		this.cache[key] = node
		this.addToHead(node)
		this.size++
		for this.size > this.capacity {
			removedNode := this.removeTail()
			delete(this.cache, removedNode.key)
			this.size--
		}
	} else {
		node := this.cache[key]
		node.value = value
		this.moveToHead(node)
	}
}

func (this *LRUCache) removeNode(node *DLinkedNode) *DLinkedNode {
	node.prev.next = node.next
	node.next.prev = node.prev
	return node
}

func (this *LRUCache) addToHead(node *DLinkedNode) {
	node.next = this.head.next
	this.head.next.prev = node
	node.prev = this.head
	this.head.next = node
}

func (this *LRUCache) moveToHead(node *DLinkedNode) {
	this.removeNode(node)
	this.addToHead(node)
}

func (this *LRUCache) removeTail() *DLinkedNode {
	return this.removeNode(this.tail.prev)
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
```






## ✅ [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)




**方法一：基于快速排序的选择方法**

快速选择算法思路：

只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案。
如果划分得到的 q 正好就是我们需要的下标，就直接返回 a[q]；
否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。

``` go
func findKthLargest(A []int, k int) int {
	n := len(A)
	return quickSelect(A, 0, n-1, n-k)
}
func quickSelect(A []int, l, r, k int) int { // kSmallest
	if l == r {
		return A[k]
	}
	pivot := A[l+(r-l)>>1] // A[(l+r)/2]
	i, j := l-1, r+1
	for i < j {
		for i++; A[i] < pivot; i++ {
		}
		for j--; A[j] > pivot; j-- {
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		}
	}
	if k <= j {
		return quickSelect(A, l, j, k)
	} else {
		return quickSelect(A, j+1, r, k)
	}
}
```



复杂度分析

- 时间复杂度：O(n)，如上文所述，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。
- 空间复杂度：O(logn)，递归使用栈空间的空间代价的期望为 O(logn)。




* 考点1：能否实现解法的优化
* 考点2：是否了解快速选择算法
* 考点3：能否说明堆算法和快速选择算法的适用场景



**方法二：基于堆排序的选择方法**

思路和算法

建立一个大根堆，做 k - 1 次删除操作后堆顶元素就是我们要找的答案。

``` go
func findKthLargest(A []int, k int) int {
	heap_size, n := len(A), len(A)
	build_maxheap(A, heap_size)
	for i := heap_size - 1; i >= n-k+1; i-- {
		A[0], A[i] = A[i], A[0]
		heap_size--
		max_heapify(A, 0, heap_size)
	}
	return A[0]
}
func build_maxheap(A []int, heap_size int) {
	for i := heap_size >> 1; i >= 0; i-- {
		max_heapify(A, i, heap_size)
	}
}
func max_heapify(A []int, i, heap_size int) {
	lson, rson, largest := i<<1+1, i<<1+2, i
	if lson < heap_size && A[largest] < A[lson] {
		largest = lson
	}
	if rson < heap_size && A[largest] < A[rson] {
		largest = rson
	}
	if i != largest {
		A[i], A[largest] = A[largest], A[i]
		max_heapify(A, largest, heap_size)
	}
}
```

复杂度分析

- 时间复杂度：O(nlogn)，建堆的时间代价是 O(n)，删除的总代价是 O(klogn)，因为 k < n，故渐进时间复杂为 O(n+klogn)=O(nlogn)。
- 空间复杂度：O(logn)，即递归使用栈空间的空间代价。




## ✅ [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)



``` go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
	dummy := &ListNode{Next: head}
	prev := dummy
	for head != nil {
		tail := prev
		for i := 0; i < k; i++ {
			tail = tail.Next
			if tail == nil {
				return dummy.Next
			}
		}
		temp := tail.Next
		tail.Next = nil
		prev.Next = reverse(head)
		prev = head
		prev.Next = temp
		head = temp
	}
	return dummy.Next
}

func reverse(head *ListNode) *ListNode {
	var prev *ListNode
	curr := head
	for curr != nil {
		temp := curr.Next
		curr.Next = prev
		prev = curr
		curr = temp
	}
	return prev
}
```







## [补充题4. 手撕快速排序 (912. 排序数组)](https://leetcode-cn.com/problems/sort-an-array/)




**简写**

``` go
func sortArray(A []int) []int {
	quickSort(A, 0, len(A)-1)
	return A
}

func quickSort(A []int, l, r int) {
	if l >= r {
		return
	}
	x := A[(l+r)>>1]
	i, j := l-1, r+1
	for i < j {
		for i++; A[i] < x; i++ {}
		for j--; A[j] > x; j-- {}
		if i < j {
			A[i], A[j] = A[j], A[i]
		}
	}
	quickSort(A, l, j)
	quickSort(A, j+1, r)
}
```

**3数中值分割优化**

``` go
func sortArray(nums []int) []int {
	quickSort(nums, 0, len(nums)-1)
	return nums
}

func quickSort(A []int, l, r int) {
	if l >= r {
		return
	}
	piv_pos := partition(A, l, r)
	quickSort(A, l, piv_pos)
	quickSort(A, piv_pos+1, r)
}

func partition(A []int, l, r int) int {
	pivot := median3(A, l, r)
	i, j := l-1, r+1
	for i < j {
		for i++; A[i] < pivot; i++ {
		}
		for j--; A[j] > pivot; j-- {
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		}
	}
	return j
}

// 三数中值分割，减少 5% 运行时间
func median3(A []int, l, r int) int {
	mid := l + ((r - l) >> 1)
	if A[l] > A[mid] {
		A[l], A[mid] = A[mid], A[l]
	}
	if A[l] > A[r] {
		A[l], A[r] = A[r], A[l]
	}
	if A[mid] > A[r] {
		A[r], A[mid] = A[mid], A[r]
	}
	return A[mid] // A[l] <= A[mid] <= A[r]
}
```



**1. 最优解**

``` go
func sortArray(nums []int) []int {
	quickSort(nums, 0, len(nums)-1)
	return nums
}

func quickSort(A []int, l, r int) {
	Cutoff := 3
	if l+Cutoff <= r {
		piv_pos := partition(A, l, r)
		quickSort(A, l, piv_pos-1)
		quickSort(A, piv_pos+1, r)
	} else { // Do an insortion sort on the subarry
		InsertionSort(A, l, r)
	}
}

func partition(A []int, l, r int) int {
	pivot := median3(A, l, r)
	i, j := l, r-1
	for {
		for i++; A[i] < pivot; i++ {
		}
		for j--; A[j] > pivot; j-- {
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		} else {
			break
		}
	}
	A[i], A[r-1] = A[r-1], A[i] // Restore pivot
	return i
}

// 三数中值分割，减少 5% 运行时间
func median3(A []int, l, r int) int {
	mid := l + ((r - l) >> 1)
	if A[l] > A[mid] {
		A[l], A[mid] = A[mid], A[l]
	}
	if A[l] > A[r] {
		A[l], A[r] = A[r], A[l]
	}
	if A[mid] > A[r] {
		A[r], A[mid] = A[mid], A[r]
	}
	// A[l] <= A[mid] <= A[r]
	A[mid], A[r-1] = A[r-1], A[mid] // Hide pivot
	return A[r-1]                   // return pivot
}

// 很小数组（n <= 20),快排不如插入排序，减少 15% 运行时间,一种好的截止范围 cutoff = 10
func InsertionSort(A []int, l, r int) {
	for i := l; i <= r; i++ {
		temp, j := A[i], i           // temp 插入元素
		for j > 0 && temp < A[j-1] { // 如果新元素小于有序元素
			A[j] = A[j-1] // 右移
			j--           // 向左扫描
		}
		A[j] = temp // 插入新元素
	}
}

// @lc code=r
```