

1. [✅ 102. 二叉树的层序遍历](#-102-二叉树的层序遍历)
2. [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
3. [141. 环形链表](#141-环形链表)
4. [33. 搜索旋转排序数组](#33-搜索旋转排序数组)
5. [103. 二叉树的锯齿形层序遍历](#103-二叉树的锯齿形层序遍历)
6. [20. 有效的括号](#20-有效的括号)
7. [200. 岛屿数量](#200-岛屿数量)
8. [5. 最长回文子串](#5-最长回文子串)
9. [88. 合并两个有序数组](#88-合并两个有序数组)
10. [236. 二叉树的最近公共祖先](#236-二叉树的最近公共祖先)





## ✅ [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func levelOrder(root *TreeNode) [][]int {
	res := [][]int{}
	if root == nil {
		return res
	}
	q := []*TreeNode{root}
	for level := 0; len(q) > 0; level++ {
		res = append(res, []int{})
		next := []*TreeNode{}
		for j := 0; j < len(q); j++ {
			node := q[j]
			res[level] = append(res[level], node.Val)
			if node.Left != nil {
				next = append(next, node.Left)
			}
			if node.Right != nil {
				next = append(next, node.Right)
			}
		}
		q = next
	}
	return res
}
```


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
var res [][]int

func levelOrder(root *TreeNode) [][]int {
	res = [][]int{}
	dfs(root, 0)
	return res
}
func dfs(node *TreeNode, level int) {
	if node != nil {
		if level == len(res) {
			res = append(res, []int{})
		}
		res[level] = append(res[level], node.Val)
		if node.Left != nil {
			dfs(node.Left, level+1)
		}
		if node.Right != nil {
			dfs(node.Right, level+1)
		}
	}
}
```


## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```go
// 最低价格买入，最高价格卖出
func maxProfit(prices []int) int {
	min_price, max_profit := math.MaxInt64, 0
	for _, price := range prices {
		if price < min_price {
			min_price = price // 最低价格
		} else if max_profit < price-min_price {
			max_profit = price - min_price // 最高利润
		}
	}
	return max_profit
}
```



```go
func maxProfit(prices []int) int {
	buy := math.MinInt64 // 买入之后的余额
	sell := 0            // 卖出之后的余额
	for _, p := range prices {
		// 无论买/卖，保证手里的钱最多
		if buy < -p {
			buy = -p
		}
		if sell < buy+p {
			sell = buy + p
		}
	}
	return sell
}
```

```go
func maxProfit(prices []int) int {
	buy := math.MinInt64 // 买入之后的余额
	sell := 0            // 卖出之后的余额
	for _, p := range prices {
		buy = max(buy, -p) // 无论买/卖，保证手里的钱最多
		sell = max(sell, buy+p)
	}
	return sell
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```



[参考](https://www.bilibili.com/video/BV1hQ4y1R7pL)






## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
	slow, fast := head, head
	for fast != nil && fast.Next != nil {
		fast = fast.Next.Next
		slow = slow.Next
		if slow == fast {
			return true
		}
	}
	return false
}
```





## [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)


```go
func search(nums []int, target int) int {
	l, r := 0, len(nums)-1
	for l <= r {
		mid := l + (r-l)>>1
		if nums[mid] == target {
			return mid
		}
		if nums[l] <= nums[mid] { // 左边有序
			if nums[l] <= target && target < nums[mid] { // target在左边
				r = mid - 1 // 舍弃右边
			} else {
				l = mid + 1
			}
		} else { // 右边有序
			if nums[mid] < target && target <= nums[r] {
				l = mid + 1
			} else {
				r = mid - 1
			}
		}
	}
	return -1
}
```


[参考](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/)




## [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)


```go

```

## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)



```go

```









## [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)





## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```go

```




## [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)








## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)





