

1. [✅ 102. 二叉树的层序遍历](#-102-二叉树的层序遍历)
2. [✅ 121. 买卖股票的最佳时机](#-121-买卖股票的最佳时机)
3. [✅ 141. 环形链表](#-141-环形链表)
4. [✅ 33. 搜索旋转排序数组](#-33-搜索旋转排序数组)
5. [✅ 103. 二叉树的锯齿形层序遍历](#-103-二叉树的锯齿形层序遍历)
6. [✅ 20. 有效的括号](#-20-有效的括号)
7. [✅ 200. 岛屿数量](#-200-岛屿数量)
8. [5. 最长回文子串](#5-最长回文子串)
9. [88. 合并两个有序数组](#88-合并两个有序数组)
10. [236. 二叉树的最近公共祖先](#236-二叉树的最近公共祖先)





## ✅ [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func levelOrder(root *TreeNode) [][]int {
	res := [][]int{}
	if root == nil {
		return res
	}
	q := []*TreeNode{root}
	for level := 0; len(q) > 0; level++ {
		res = append(res, []int{})
		next := []*TreeNode{}
		for _, node := range q {
			res[level] = append(res[level], node.Val)
			if node.Left != nil {
				next = append(next, node.Left)
			}
			if node.Right != nil {
				next = append(next, node.Right)
			}
		}
		q = next
	}
	return res
}
```


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
var res [][]int

func levelOrder(root *TreeNode) [][]int {
	res = [][]int{}
	dfs(root, 0)
	return res
}
func dfs(node *TreeNode, level int) {
	if node != nil {
		if level == len(res) {
			res = append(res, []int{})
		}
		res[level] = append(res[level], node.Val)
		if node.Left != nil {
			dfs(node.Left, level+1)
		}
		if node.Right != nil {
			dfs(node.Right, level+1)
		}
	}
}
```


## ✅ [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```go
// 最低价格买入，最高价格卖出
func maxProfit(prices []int) int {
	min_price, max_profit := math.MaxInt64, 0
	for _, price := range prices {
		if price < min_price {
			min_price = price // 最低价格
		} else if max_profit < price-min_price {
			max_profit = price - min_price // 最高利润
		}
	}
	return max_profit
}
```



```go
func maxProfit(prices []int) int {
	buy := math.MinInt64 // 买入之后的余额
	sell := 0            // 卖出之后的余额
	for _, p := range prices {
		// 无论买/卖，保证手里的钱最多
		if buy < -p {
			buy = -p
		}
		if sell < buy+p {
			sell = buy + p
		}
	}
	return sell
}
```

```go
func maxProfit(prices []int) int {
	buy := math.MinInt64 // 买入之后的余额
	sell := 0            // 卖出之后的余额
	for _, p := range prices {
		buy = max(buy, -p) // 无论买/卖，保证手里的钱最多
		sell = max(sell, buy+p)
	}
	return sell
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```



[参考](https://www.bilibili.com/video/BV1hQ4y1R7pL)






## ✅ [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
	slow, fast := head, head
	for fast != nil && fast.Next != nil {
		fast = fast.Next.Next
		slow = slow.Next
		if slow == fast {
			return true
		}
	}
	return false
}
```





## ✅ [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)


```go
func search(nums []int, target int) int {
	l, r := 0, len(nums)-1
	for l <= r {
		mid := l + (r-l)>>1
		if nums[mid] == target {
			return mid
		}
		if nums[l] <= nums[mid] { // 左边有序
			if nums[l] <= target && target < nums[mid] { // target在左边
				r = mid - 1 // 舍弃右边
			} else {
				l = mid + 1
			}
		} else { // 右边有序
			if nums[mid] < target && target <= nums[r] {
				l = mid + 1
			} else {
				r = mid - 1
			}
		}
	}
	return -1
}
```


[参考](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/)




## ✅ [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
var res [][]int

func zigzagLevelOrder(root *TreeNode) [][]int {
	res = [][]int{}
	dfs(root, 0)
	return res
}
func dfs(root *TreeNode, level int) {
	if root != nil {
		if level == len(res) {
			res = append(res, []int{})
		}
		if level%2 == 0 {
			res[level] = append(res[level], root.Val)
		} else {
			res[level] = append([]int{root.Val}, res[level]...)
		}
		dfs(root.Left, level+1)
		dfs(root.Right, level+1)
	}
}
```


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func zigzagLevelOrder(root *TreeNode) [][]int {
	res := [][]int{}
	if root == nil {
		return res
	}
	queue := []*TreeNode{root}
	for level := 0; len(queue) > 0; level++ {
		res = append(res, []int{})
		next, q := []int{}, queue
		queue = nil
		for _, node := range q {
			next = append(next, node.Val)
			if node.Left != nil {
				queue = append(queue, node.Left)
			}
			if node.Right != nil {
				queue = append(queue, node.Right)
			}
		}
		if level%2 == 1 {
			for i := 0; i < len(next)>>1; i++ {
				next[i], next[len(next)-1-i] = next[len(next)-1-i], next[i]
			}
		}
		res[level] = append(res[level], next...)
	}
	return res
}
```

## ✅ [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)



```go
func isValid(s string) bool {
	stack := []rune{}
	for _, v := range s {
		if v == '(' || v == '[' || v == '{' {
			stack = append(stack, v)
		} else if len(stack) > 0 && stack[len(stack)-1] == '(' && v == ')' ||
			len(stack) > 0 && stack[len(stack)-1] == '[' && v == ']' ||
			len(stack) > 0 && stack[len(stack)-1] == '{' && v == '}' {
			stack = stack[:len(stack)-1]
		} else {
			return false
		}
	}
	return len(stack) == 0
}
```









## ✅ [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)


```go
func numIslands(grid [][]byte) int {
	count := 0
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			if grid[i][j] == '1' {
				count++
				dfs(grid, i, j)
			}
		}
	}
	return count
}
func dfs(grid [][]byte, i, j int) {
	if 0 <= i && i < len(grid) && 0 <= j && j < len(grid[0]) && grid[i][j] == '1' {
		grid[i][j] = '0'
		dfs(grid, i-1, j)
		dfs(grid, i+1, j)
		dfs(grid, i, j-1)
		dfs(grid, i, j+1)
	}
}
```



## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```go

```




## [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)


```go

```






## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)


```go

```



