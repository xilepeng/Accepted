
1. [✅手撕快速排序](#手撕快速排序)
2. [✅手撕归并排序](#手撕归并排序)
3. [✅手撕堆排序](#手撕堆排序)
4. [📝插入排序](#插入排序)
5. [📝希尔排序](#希尔排序)
6. [📝选择排序](#选择排序)
7. [📝冒泡排序](#冒泡排序)
8. [Counting Sort](#counting-sort)
9. [Bucket Sort](#bucket-sort)
10. [Radix Sort](#radix-sort)


## [✅手撕快速排序](https://leetcode-cn.com/problems/sort-an-tmparray/)

**简写**

``` go
func sortArray(A []int) []int {
	quickSort(A, 0, len(A)-1)
	return A
}

func quickSort(A []int, l, r int) {
	if l >= r {
		return
	}
	x := A[l+(r-l)>>1]
	i, j := l-1, r+1
	for i < j {
		for i++; A[i] < x; i++ {
		}
		for j--; A[j] > x; j-- {
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		}
	}
	quickSort(A, l, j)
	quickSort(A, j+1, r)
}
```

```go
func sortArray(nums []int) []int {
	quickSort(nums, 0, len(nums)-1)
	return nums
}
func quickSort(A []int, l, r int) {
	if l >= r {
		return
	}
	piv_pos := partition(A, l, r)
	quickSort(A, l, piv_pos)
	quickSort(A, piv_pos+1, r)
}
func partition(A []int, l, r int) int {
	x := A[(l+r)/2]
	i, j := l-1, r+1
	for {
		for i++; A[i] < x; i++ {
		}
		for j--; A[j] > x; j-- {
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		} else {
			break
		}
	}
	return j
}
```

**3数中值分割优化**

``` go
func sortArray(nums []int) []int {
	quickSort(nums, 0, len(nums)-1)
	return nums
}

func quickSort(A []int, l, r int) {
	if l >= r {
		return
	}
	piv_pos := partition(A, l, r)
	quickSort(A, l, piv_pos)
	quickSort(A, piv_pos+1, r)
}

func partition(A []int, l, r int) int {
	pivot := median3(A, l, r)
	i, j := l-1, r+1
	for i < j {
		for i++; A[i] < pivot; i++ {
		}
		for j--; A[j] > pivot; j-- {
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		}
	}
	return j
}

// 三数中值分割，减少 5% 运行时间
func median3(A []int, l, r int) int {
	mid := l + (r - l) >> 1
	if A[l] > A[mid] {
		A[l], A[mid] = A[mid], A[l]
	}
	if A[l] > A[r] {
		A[l], A[r] = A[r], A[l]
	}
	if A[mid] > A[r] {
		A[r], A[mid] = A[mid], A[r]
	}
	return A[mid] // A[l] <= A[mid] <= A[r]
}
```




## [✅手撕归并排序](https://leetcode.cn/problems/sort-an-tmparray/)

``` go
func sortArray(nums []int) []int {
	mergeSort(nums, 0, len(nums)-1)
	return nums
}

func merge1(A []int, start, mid, end int) {
	tmp := make([]int, end-start+1)
	i, j, k := start, mid+1, 0
	for i <= mid && j <= end {
		if A[i] < A[j] {
			tmp[k] = A[i]
			i++
		} else {
			tmp[k] = A[j]
			j++
		}
		k++
	}
	for i <= mid {
		tmp[k] = A[i]
		i++
		k++
	}
	for j <= end {
		tmp[k] = A[j]
		j++
		k++
	}
	for p := 0; p < k; p++ {
		A[start] = tmp[p]
		start++
	}
}

func merge2(A []int, start, mid, end int) {
	tmpArr := make([]int, end-start+1)
	i, j, k := start, mid+1, 0
	for p := start; p <= end; p++ {
		if j > end || (i <= mid && A[i] < A[j]) {
			tmpArr[k] = A[i]
			i++
		} else {
			tmpArr[k] = A[j]
			j++
		}
		k++
	}
	for p := 0; p < k; p++ {
		A[start] = tmpArr[p]
		start++
	}
}

func merge3(A []int, start, mid, end int) {
	tmpArr := make([]int, end-start+1)
	i, j, k := start, mid+1, 0
	for p := start; p <= end; p++ {
		if i > mid {
			tmpArr[k] = A[j]
			j++
		} else if j > end {
			tmpArr[k] = A[i]
			i++
		} else if A[i] <= A[j] {
			tmpArr[k] = A[i]
			i++
		} else {
			tmpArr[k] = A[j]
			j++
		}
		k++
	}
	for p := 0; p < k; p++ {
		A[start] = tmpArr[p]
		start++
	}
}

func mergeSort(A []int, start, end int) {
	if start >= end {
		return
	}
	mid := start + (end-start)>>1 // mid := (start + end) / 2
	mergeSort(A, start, mid)
	mergeSort(A, mid+1, end)
	// merge1(A, start, mid, end)
	// merge2(A, start, mid, end)
	merge3(A, start, mid, end)
}
```


## [✅手撕堆排序](https://leetcode-cn.com/problems/sort-an-tmparray/)

``` go
func sortArray(A []int) []int {
	heapSort(A)
	return A
}

// 在大根堆中、最大元素总在根上，堆排序使用堆的这个属性进行排序
func heapSort(A []int) {
	heapSize := len(A) - 1
	buildMaxHeap(A, heapSize) // A[0]为堆顶
	for i := heapSize; i > 0; i-- {
		A[0], A[i] = A[i], A[0] // 交换堆顶元素 A[0] 与堆底元素 A[i]，最大值 A[0] 放置在数组末尾
		heapSize--              // 删除堆顶元素 A[0]
		// maxHeapify1(A, 0, heapSize) // 堆顶元素 A[0] 向下调整
		maxHeapify(A, 0, heapSize) // 堆顶元素 A[0] 向下调整
	}
}

// 建堆 O(n)
func buildMaxHeap(A []int, heapSize int) {
	for i := heapSize >> 1; i >= 0; i-- { // heapSize / 2 后面都是叶子节点，不需要向下调整
		maxHeapify(A, i, heapSize)
	}
}

// 迭代: 调整大根堆 O(n)
func maxHeapify(A []int, i, heapSize int) {
	for i<<1+1 <= heapSize { // i*2+1
		lson, rson, large := i<<1+1, i<<1+2, i
		if lson <= heapSize && A[large] < A[lson] {
			large = lson
		}
		if rson <= heapSize && A[large] < A[rson] {
			large = rson
		}
		if large != i {
			A[i], A[large] = A[large], A[i]
			i = large
		} else {
			break
		}
	}
}

// 递归: 调整大根堆 O(nlogn)
func maxHeapify1(A []int, i, heapSize int) {
	lson, rson, largest := i<<1+1, i<<1+2, i      // i*2+1, i*2+2
	if lson <= heapSize && A[largest] < A[lson] { // 左儿子存在并大于根
		largest = lson
	}
	if rson <= heapSize && A[largest] < A[rson] { // 右儿子存在并大于根
		largest = rson
	}
	if i != largest { // 找到左右儿子的最大值
		A[i], A[largest] = A[largest], A[i] // 堆顶调整为最大值
		maxHeapify1(A, largest, heapSize)   // 递归调整子树
	}
}
```

## [📝插入排序](https://leetcode-cn.com/problems/sort-an-tmparray/)


``` go

```

## [📝希尔排序](https://leetcode-cn.com/problems/sort-an-tmparray/)

``` go

```

## [📝选择排序](https://leetcode-cn.com/problems/sort-an-tmparray/)

``` go

```


## [📝冒泡排序](https://leetcode-cn.com/problems/sort-an-tmparray/)

``` go

```

## [Counting Sort](https://www.hackerearth.com/practice/algorithms/sorting/counting-sort/tutorial/)

``` go

```


## [Bucket Sort](https://www.hackerearth.com/practice/algorithms/sorting/bucket-sort/tutorial/)

``` go

```

## [Radix Sort](https://www.hackerearth.com/practice/algorithms/sorting/radix-sort/tutorial/)


``` go

```