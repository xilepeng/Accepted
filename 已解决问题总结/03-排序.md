

1. [✅手撕快速排序](#手撕快速排序)
2. [✅手撕归并排序](#手撕归并排序)
3. [✅手撕堆排序](#手撕堆排序)
4. [📝插入排序](#插入排序)
5. [📝希尔排序](#希尔排序)
6. [📝选择排序](#选择排序)
7. [📝冒泡排序](#冒泡排序)
8. [Counting Sort](#counting-sort)
9. [Bucket Sort](#bucket-sort)
10. [Radix Sort](#radix-sort)




## [✅手撕快速排序](https://leetcode-cn.com/problems/sort-an-tmparray/)

**1.优雅写法**

```go
func sorttmpArray(A []int) []int {
	quickSort(A, 0, len(A)-1)
	return A
}

// 快速排序 O(nlogn) 是一种基于“分治思想”的排序算法 
// 1. 选取数组某个元素为基准数，
// 2. 将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边,
// 3. 递归处理左右两边。
func quickSort(A []int, low, high int) {
	if low >= high {
		return
	}
	pos := partition(A, low, high)
	quickSort(A, low, pos-1)
	quickSort(A, pos+1, high)
}

func partition(A []int, low, high int) int {
	A[high], A[low+(high-low)>>1] = A[low+(high-low)>>1], A[high] // 以 A[high] 作为基准数
	i, j := low, high
	for i < j {
		for i < j && A[i] <= A[high] { // 从左向右找首个大于基准数的元素
			i++
		}
		for i < j && A[j] >= A[high] { // 从右向左找首个小于基准数的元素
			j--
		}
		A[i], A[j] = A[j], A[i] // 元素交换到正确的区间
	}
	A[i], A[high] = A[high], A[i] // 将基准数交换至两子数组的分界线
	return i                      // 返回基准数的索引
}

// 快速排序（尾递归优化）
func quickSort(A []int, low, high int) {
	for low < high { // 子数组长度为 1 时终止
		pos := partition(A, low, high) // 哨兵划分操作
		// 对两个子数组中较短的那个执行快排
		if pos-low < high-pos {
			quickSort(A, low, pos-1) // 递归排序左子数组
			low = pos + 1            // 剩余待排序区间为 [pos + 1, high]
		} else {
			quickSort(A, pos+1, high) // 递归排序右子数组
			high = pos - 1            // 剩余待排序区间为 [low, pos - 1]
		}
	}
}
```


*2.更快写法*

```go
func sorttmpArray(A []int) []int {
	quickSort(A, 0, len(A)-1)
	return A
}



// 快速排序 O(nlogn) 是一种基于“分治思想”的排序算法 
// 1. 选取数组某个元素为基准数，
// 2. 将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边,
// 3. 递归处理左右两边。
func quickSort(A []int, low, high int) {
	if low >= high {
		return
	}
	j := partition(A, low, high)
	quickSort(A, low, j)
	quickSort(A, j+1, high)
}


func partition(A []int, low, high int) int {
	pivot := A[low+(high-low)>>1]
	i, j := low-1, high+1
	for i < j {
		for {
			i++
			if A[i] >= pivot {
				break
			}
		}
		for {
			j--
			if A[j] <= pivot {
				break
			}
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		}
	}
	return j
}

func Partition(A []int, low, high int) int {
	pivot := A[low+(high-low)>>1]
	i, j := low-1, high+1
	for i < j {
		for i++; A[i] < pivot; i++ {
		}
		for j--; A[j] > pivot; j-- {
		}
		if i < j {
			A[i], A[j] = A[j], A[i]
		}
	}
	return j
}
```



## [✅手撕归并排序](https://leetcode.cn/problems/sort-an-tmparray/)

```go
func sorttmpArray(A []int) []int {
	mergeSort(A, 0, len(A)-1)
	return A
}


//「归并排序 Merge Sort」是算法中“分治思想”的典型体现，其有「划分」和「合并」两个阶段：

// 1. 划分阶段：通过递归不断 将数组从中点位置划分开，将长数组的排序问题转化为短数组的排序问题；
// 2. 合并阶段：划分到子数组长度为 1 时，开始向上合并，不断将 左、右两个短排序数组 合并为 一个长排序数组，直至合并至原数组时完成排序；
// O(nlogn)
func mergeSort(A []int, low, high int) {
	// 终止条件
	if low >= high { 
		return
	}
	mid := low + (high-low)>>1  
	// 划分阶段
	mergeSort(A, low, mid)    
	mergeSort(A, mid+1, high)   
	// 合并阶段
	merge(A, low, mid, high)    

}

/* 合并左子数组和右子数组 */
// 左子数组区间 [left, mid]
// 右子数组区间 [mid + 1, right]

func merge(A []int, low, mid, high int) {
	tmpArr := make([]int, high-low+1)
	i, j, k := low, mid+1, 0 // i, j 分别指向左子数组、右子数组的首元素
	for p := low; p <= high; p++ {
		if j > high || (i <= mid && A[i] < A[j]) { // 如果 “右子数组已全部合并完” 或 “左子数组元素 <= 右子数组元素”
			tmpArr[k] = A[i] // 选取左子数组元素
			i++			  // 扫描下一个数
		} else {
			tmpArr[k] = A[j]
			j++
		}
		k++
	}
	copy(A[low:high+1], tmpArr)
}


func merge1(A []int, low, mid, high int) {
	tmpArr := make([]int, high-low+1)
	i, j, k := low, mid+1, 0
	for p := low; p <= high; p++ {
		if i > mid { // 检查第一部分是否到达末尾
			tmpArr[k] = A[j]
			j++
		} else if j > high { // 检查第二部分是否到达末尾
			tmpArr[k] = A[i]
			i++
		} else if A[i] <= A[j] { // 检查哪一部分有更小的元素
			tmpArr[k] = A[i]
			i++
		} else {
			tmpArr[k] = A[j]
			j++
		}
		k++
	}
	for p := 0; p < k; p++ {
		A[low] = tmpArr[p]
		low++
	}
}

func merge2(A []int, low, mid, high int) {
	tmpArr := make([]int, high-low+1)
	i, j, k := low, mid+1, 0
	for i <= mid && j <= high {
		if A[i] < A[j] {
			tmpArr[k] = A[i]
			i++
		} else {
			tmpArr[k] = A[j]
			j++
		}
        k++
}
	for ; i <= mid; i++ {
		tmpArr[k] = A[i]
		k++
	}
	for ; j <= high; j++ {
		tmpArr[k] = A[j]
		k++
	}
	copy(A[low:high+1], tmpArr)
}
```

## [✅手撕堆排序](https://leetcode-cn.com/problems/sort-an-tmparray/)


**大根堆：升序**

```go
func sorttmpArray(A []int) []int {
	heapSort(A)
	return A
}

// 在大根堆中、最大元素总在根上，堆排序使用堆的这个属性进行排序
func heapSort(A []int) {
	heapSize := len(A)
	buildMaxHeap(A, heapSize)
	for i := heapSize - 1; i >= 0; i-- {
		A[0], A[i] = A[i], A[0]    // 交换堆顶元素 A[0] 与堆底元素 A[i]，最大值 A[0] 放置在数组末尾
		heapSize--                 // 删除堆顶元素 A[0]
		maxHeapify(A, 0, heapSize) // 堆顶元素 A[0] 向下调整
	}
}

// 建堆 O(n)
func buildMaxHeap(A []int, heapSize int) {
	for i := heapSize >> 1; i >= 0; i-- { // heapSize / 2 后面都是叶子节点，不需要向下调整
		maxHeapify(A, i, heapSize)
	}
}

// 迭代: 调整大根堆 O(n)
func maxHeapify(A []int, i, heapSize int) {
	for i<<1+1 < heapSize { // i*2+1
		lson, rson, large := i<<1+1, i<<1+2, i
		if lson < heapSize && A[large] < A[lson] {
			large = lson
		}
		for rson < heapSize && A[large] < A[rson] {
			large = rson
		}
		if large != i {
			A[i], A[large] = A[large], A[i]
			i = large
		} else {
			break
		}
	}
}

// 递归: 调整大根堆 O(nlogn)
func MaxHeapify(A []int, i, heapSize int) {
	lson, rson, largest := i<<1+1, i<<1+2, i     // i*2+1, i*2+2
	if lson < heapSize && A[largest] < A[lson] { // 左儿子存在并大于根
		largest = lson
	}
	if rson < heapSize && A[largest] < A[rson] { // 右儿子存在并大于根
		largest = rson
	}
	if i != largest { // 找到左右儿子的最大值
		A[i], A[largest] = A[largest], A[i] // 堆顶调整为最大值
		MaxHeapify(A, largest, heapSize)    // 递归调整子树
	}
}
```


**小根堆：降序**
```go
func sorttmpArray(A []int) []int {
	heapSort(A)
	return A
}

func heapSort(A []int) {
	heapSize := len(A)
	buildHeap(A, heapSize)
	for i := heapSize - 1; i >= 0; i-- {
		A[0], A[i] = A[i], A[0]
		heapSize--
		minHeapify(A, 0, heapSize)
	}
}

func buildHeap(A []int, heapSize int) {
	for i := heapSize >> 1; i >= 0; i-- {
		minHeapify(A, i, heapSize)
	}
}

// 小根堆：逆序
func minHeapify(A []int, i, heapSize int) {
	for i<<1+1 < heapSize {
		lson, rson, small := i<<1+1, i<<1+2, i
		for lson < heapSize && A[lson] < A[small] {
			small = lson
		}
		for rson < heapSize && A[rson] < A[small] {
			small = rson
		}
		if small != i {
			A[i], A[small] = A[small], A[i]
			i = small
		} else {
			break
		}
	}
}

func MinHeapify(A []int, i, heapSize int) {
	lson, rson, small := i<<1+1, i<<1+2, i
	for lson < heapSize && A[small] < A[lson] {
		small = lson
	}
	for rson < heapSize && A[small] < A[rson] {
		small = rson
	}
	if small != i {
		A[i], A[small] = A[small], A[i]
		MinHeapify(A, small, heapSize)
	}
}
```






```go
/*
 * @lc app=leetcode.cn id=912 lang=golang
 *
 * [912] 排序数组
 */

// @lc code=low
func sorttmpArray(A []int) []int {
	InsertSort(A)
	SelectionSort(A)
	BubbleSort(A)
	
	return A
}

```

## [📝插入排序](https://leetcode-cn.com/problems/sort-an-tmparray/)

```go
// 插入排序
// 取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序
func InsertSort(A []int) {
	for i := 0; i < len(A); i++ {
		base, j := A[i], i 
		// 内循环：将 base 插入到左边的正确位置
		for; j > 0 && A[j-1] > base; j-- { // 向左扫描
			A[j] = A[j-1] // 1. 将 nums[j-1] 向右移动一位       
		}
		A[j] = base       // 2. 将 base 赋值到正确位置
	}
}

func insertSort(A []int) {
	for i := 1; i < len(A); i++ {
		base, j := A[i], i
		for ; j > 0; j-- {
			if A[j-1] > base {
				A[j] = A[j-1]
			} else {
				break
			}
		}
		A[j] = base
	}
}

func InsertSort1(A []int) {
	for i := 1; i < len(A); i++ {
		base, j := A[i], i-1
		// 内循环：将 base 插入到左边的正确位置
		for ; j >= 0 && A[j] > base; j-- { 
			A[j+1] = A[j] // 1. 将 A[j] 向右移动一位
		}
		A[j+1] = base     // 2. 将 base 赋值到正确位置
	}
}

```

## [📝希尔排序](https://leetcode-cn.com/problems/sort-an-tmparray/)

```go
// 希尔排序
// 先通过希尔增量逐步分组粗排，再插入排序
func ShellSort(A []int, n int) {
	for d := n >> 1; d > 0; d >>= 1 { // 希尔增量 d=n/2
		for i := d; i < n; i++ {
			temp, j := A[i], i
			for j >= d && temp < A[j-d] {
				A[j] = A[j-d] // 较大数右移一位
				j -= d        // 向左搜索
			}
			A[j] = temp // 插入
		}
	}
}

func ShellSort1(A []int, n int) {
	for d := n >> 1; d > 0; d >>= 1 { // 希尔增量 d=n/2
		for i := d; i < n; i++ {
			temp, j := A[i], i-d
			for j >= 0 && temp < A[j] {
				A[j+d] = A[j] // 较大数右移一位
				j -= d        // 向左搜索
			}
			A[j+d] = temp // 插入
		}
	}
}
```


## [📝选择排序](https://leetcode-cn.com/problems/sort-an-tmparray/)

```go
// 选择排序(不稳定)
// 每次从未排序区间中找到最小的元素，将其放到已排序区间的末尾。
func SelectionSort(A []int) {
	for i := 0; i < len(A); i++ {
		minPos := i
		for j := i + 1; j < len(A); j++ {
			if A[j] < A[minPos] {
				minPos = j // 查找最小值下标
			}
		} // 将最小值交换到有序区
		A[i], A[minPos] = A[minPos], A[i]
	}
}
```

## [📝冒泡排序](https://leetcode-cn.com/problems/sort-an-tmparray/)

```go
// 冒泡排序
// 从前往后遍历，如果前一个数大于后一个数，交换，一次冒泡一个元素已排序，重复n次。

func bubbleSort(A []int) {
	// 外循环：待排序元素数量为 n-1, n-2, ..., 1
	for i := len(A) - 1; i > 0; i-- {
		// 内循环：冒泡操作
		for j := 0; j < i; j++ {
			if A[j] > A[j+1] {
				// 交换 nums[j] 与 nums[j + 1]
				A[j], A[j+1] = A[j+1], A[j]
			}
		}
	}
}

func bubbleSort1(A []int) {
	// 外循环：待排序元素数量为 n-1, n-2, ..., 1
	for i := len(A) - 1; i > 0; i-- {
		flag := false
		// 内循环：冒泡操作
		for j := 0; j < i; j++ {
			if A[j] > A[j+1] {
				// 交换 nums[j] 与 nums[j + 1]
				A[j], A[j+1] = A[j+1], A[j]
				flag = true
			}
		}
		if !flag {
			break
		}
	}
}




func BubbleSort(A []int, n int) {
	for i := 0; i < n-1; i++ {
		for j := 0; j < n-i-1; j++ {
			if A[j] > A[j+1] {
				A[j], A[j+1] = A[j+1], A[j]
			}
		}
	}
}

func BubbleSort1(A []int, n int) {
	if n <= 1 {
		return
	}
	for i := 0; i < n-1; i++ {
		flag := false // 提前退出冒泡循环的标志位
		for j := 0; j < n-i-1; j++ {
			if A[j] > A[j+1] {
				A[j], A[j+1] = A[j+1], A[j] // 交换相邻的2个元素
				flag = true                 // 表示有数据要交换
			}
		}
		if !flag { // 没有数据交换，提前退出
			break
		}
	}
}
```






## [Counting Sort](https://www.hackerearth.com/practice/algorithms/sorting/counting-sort/tutorial/)


```go

// 计数排序 模版
// 最大值是k，我们就可以把数据划分成k个桶。
// 每个桶内的数据值都是相同的，省掉了桶内排序的时间。
// [0, N-1]
func CountingSort(A []int) []int {
	// 首先找到数组的最大值 K
	K := 0
	for i := 0; i < len(A); i++ {
		if K < A[i] {
			K = A[i]
		}
	}
	// 存储数组 A 中每个元素的频率，值作为辅助数组的索引
	Aux := make([]int, K+1)
	for i := 0; i < len(A); i++ {
		Aux[A[i]]++
	}
	j := 0
	for i := 0; i <= K; i++ {
		tmp := Aux[i]
		for ; tmp > 0; tmp-- {
			A[j] = i
			j++
		}
	}
	return A
}

// 计数排序1 模版1
func CountingSort1(a []int, n int) {
	if n <= 1 {
		return
	}
	// 查找数组中数据的最大值
	var max int = math.MinInt32
	for i := range a {
		if a[i] > max {
			max = a[i]
		}
	}

	c := make([]int, max+1) // 申请一个计数数组c，下标大小[0,max]
	for i := range a {
		c[a[i]]++ // 计算每个元素的个数，放入c中
	}
	for i := 1; i <= max; i++ {
		c[i] += c[i-1] // 依次累加,c[i]存储小于等于i的个数
	}
	// 从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己在内，分数小于等于3的考生有7个，
	// 也就是说3是数组R中的第7个元素（也就是数组R中下标为6的位置）。
	// 当3放入到数组R中后，小于等于3的元素就只剩下了6个了，所以相应的C[3]要减1，变成6。
	r := make([]int, n) // 临时数组r，存储排序之后的结果
	for i := n - 1; i >= 0; i-- {
		index := c[a[i]] - 1 //
		r[index] = a[i]
		c[a[i]]--
	}
	copy(a, r)
}

// 计数排序 实例
// -5 * 104 <= A[i] <= 5 * 104
func counting_sort(A []int) []int {
	K := 1000001          // 首先找到数组 A 的最大值 K
	Aux := make([]int, K) // 辅助数组 Aux 存储数组 A 中每个元素的频率，值作为辅助数组的索引
	for i := 0; i < len(A); i++ {
		Aux[A[i]+50000]++ // 防止-50000作为索引时，下标越界
	}
	for i, j := 0, 0; i < K; i++ {
		tmp := Aux[i] // 从小到大取数字i的频率
		for ; tmp > 0; tmp-- {
			A[j] = i - 50000
			j++
		}
	}
	return A
}
```






## [Bucket Sort](https://www.hackerearth.com/practice/algorithms/sorting/bucket-sort/tutorial/)

```go

// 桶排序

// 获取待排序数组中的最大值
func getMax(a []int) int {
	max := a[0]
	for i := 1; i < len(a); i++ {
		if a[i] > max {
			max = a[i]
		}
	}
	return max
}

func BucketSort(a []int) {
	num := len(a)
	if num <= 1 {
		return
	}
	max := getMax(a)
	buckets := make([][]int, num) // 二维切片

	index := 0
	for i := 0; i < num; i++ {
		index = a[i] * (num - 1) / max // 桶序号
		fmt.Println(index)
		buckets[index] = apphigh(buckets[index], a[i]) // 加入对应的桶中
	}

	tmpPos := 0 // 标记数组位置
	for i := 0; i < num; i++ {
		bucketLen := len(buckets[i])
		if bucketLen > 0 {
			QuickSort(buckets[i], 0, len(buckets[i])-1) // 桶内做快速排序
			copy(a[tmpPos:], buckets[i])
			tmpPos += bucketLen
		}
	}

}

// 桶排序简单实现
func BucketSortSimple(source []int) {
	if len(source) <= 1 {
		return
	}
	tmparray := make([]int, getMax(source)+1)
	for i := 0; i < len(source); i++ {
		tmparray[source[i]]++
	}
	fmt.Println(tmparray)
	c := make([]int, 0)
	for i := 0; i < len(tmparray); i++ {
		for tmparray[i] != 0 {
			c = apphigh(c, i)
			tmparray[i]--
		}
	}
	copy(source, c)

}


```


## [Radix Sort](https://www.hackerearth.com/practice/algorithms/sorting/radix-sort/tutorial/)


```go
// 基数排序
// 依次按个位、十位、百位进行排序
func RadixSort(A []int, n int) {

}
```


