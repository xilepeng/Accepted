

## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)


```go
func lengthOfLongestSubstring(s string) int {
	longest, n := 0, len(s)
	freq := make(map[byte]int, n)
	for i, j := 0, 0; j < n; j++ {
		freq[s[j]]++
		for freq[s[j]] > 1 {
			freq[s[i]]--
			i++
		}
		longest = max(longest, j-i+1) // Go 1.21.1 内置 max min 函数
	}
	return longest
}

// Go 1.20.0 之前需自定义 max min
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) 

``` go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
*/
// 方法一：迭代
func reverseList(head *ListNode) *ListNode {
	var prev *ListNode
	curr := head
	for curr != nil {
		temp := curr.Next
		curr.Next = prev
		prev = curr
		curr = temp
	}
	return prev
}

// 方法二：递归
func reverseList_2(head *ListNode) *ListNode {
	if head == nil || head.Next == nil { // 递归出口：没有节点或只有一个节点
		return head
	}
	newHead := reverseList(head.Next) // 子问题
	head.Next.Next = head             // 翻转
	head.Next = nil                   // 断开旧链
	return newHead
}

// 方法三：穿针引线
func reverseList_3(head *ListNode) *ListNode {
	dummy, curr := &ListNode{Next: head}, head
	for curr != nil && curr.Next != nil { // 至少有2个节点
		temp := curr.Next
		curr.Next = temp.Next
		temp.Next = dummy.Next // 如果等于 curr，将导致断开链表
		dummy.Next = temp
	}
	return dummy.Next
}
```




## [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)



```go
type LRUCache struct {
	cache          map[int]*DLinkedNode
	head, tail     *DLinkedNode
	capacity, size int
}

type DLinkedNode struct {
	key, value int
	prev, next *DLinkedNode
}

func InitDLinkedNode(key, value int) *DLinkedNode {
	return &DLinkedNode{
		key:   key,
		value: value,
	}
}

func Constructor(capacity int) LRUCache {
	l := LRUCache{
		cache:    map[int]*DLinkedNode{},// : 不是 :=
		head:     InitDLinkedNode(0, 0),
		tail:     InitDLinkedNode(0, 0),
		capacity: capacity,
	}
	l.head.next = l.tail
	l.tail.prev = l.head
	return l
}

func (this *LRUCache) Get(key int) int {
	if _, ok := this.cache[key]; !ok {
		return -1
	} else {
		node := this.cache[key]
		this.moveToHead(node)
		return node.value
	}
}

func (this *LRUCache) Put(key int, value int) {
	if _, ok := this.cache[key]; !ok {
		node := InitDLinkedNode(key, value)
		// 忘记将节点加入缓存了
		this.cache[key] = node
		this.addToHead(node)
		this.size++
		for this.size > this.capacity {
			removedNode := this.removeTail()
			delete(this.cache, removedNode.key)
			this.size--
		}
	} else {
		node := this.cache[key]
		node.value = value
		this.moveToHead(node)
	}
}

func (this *LRUCache) removeNode(node *DLinkedNode) *DLinkedNode {
	node.prev.next = node.next
	node.next.prev = node.prev
	return node
}

func (this *LRUCache) addToHead(node *DLinkedNode) {
	node.next = this.head.next
	this.head.next.prev = node
	node.prev = this.head
	this.head.next = node
}

func (this *LRUCache) moveToHead(node *DLinkedNode) {
	this.removeNode(node)
	this.addToHead(node)
}

func (this *LRUCache) removeTail() *DLinkedNode {
	return this.removeNode(this.tail.prev)
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
```