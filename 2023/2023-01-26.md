

1. [3. 无重复字符的最长子串](#3-无重复字符的最长子串)
2. [206. 反转链表](#206-反转链表)
3. [146. LRU 缓存机制](#146-lru-缓存机制)
4. [215. 数组中的第K个最大元素](#215-数组中的第k个最大元素)
5. [25. K 个一组翻转链表](#25-k-个一组翻转链表)



## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)


**方法一：双指针 O(n)**
1. (a)bcabcbb
2. (ab)cabcbb 
3. (abc)abcbb
4. (abca)bcbb 当前字符和首字符重复
5. ~~a~~(bca)bcbb 删除首字符（收缩窗口）
6. ~~a~~(bcab)cbb 继续向后扫描（扩展窗口）
7. ~~ab~~(cab)cbb

思路：定义两个指针 i,j(i<=j)，表示当前扫描到的子串是 [i,j](闭区间)。扫描过程中维护一个哈希表 hash := map[byte]int{}，表示 [i,j]中每个字符出现的次数。线性扫描时，每次循环的流程如下：

1. 指针 j 向后移一位, 同时将哈希表中 s[j] 的计数加一: hash[s[j]]++;
2. 假设 j 移动前的区间 [i,j] 中没有重复字符，则 j 移动后，只有 s[j] 可能出现2次。因此我们不断向后移动 i，直至区间 [i,j] 中 s[j] 的个数等于1为止；
   
复杂度分析：由于 i,j 均最多增加n次，且哈希表的插入和更新操作的复杂度都是 O(1)，因此，总时间复杂度 O(n)



``` go
func lengthOfLongestSubstring(s string) int {
	hash := map[byte]int{} // 哈希集合记录每个字符出现次数
	res := 0
	for i, j := 0, 0; j < len(s); j++ {
		hash[s[j]]++                // 首次存入哈希
		for ; hash[s[j]] > 1; i++ { // 出现字符和首字符重复，i++跳过首字符(收缩窗口)
			hash[s[i]]-- // 哈希记录次数减1
		}
		res = max(res, j-i+1) // 统计无重复字符的最长子串
	}
	return res
}
func max(x, y int) int {
	if x < y {
		return y
	}
	return x
}
```
[参考](https://www.acwing.com/solution/content/49/)


**方法二：滑动窗口**

*思路一：*

1. ( **a** )bcabcbb
2. ( **ab** )cabcbb 
3. ( **abc** )abcbb
4. ( **abca** )bcbb 当前字符和首字符重复
5. ~~a~~( **bca** )bcbb 删除首字符（收缩窗口）
6. ~~a~~( **bcab** )cbb 继续向后扫描（扩展窗口）
7. ~~ab~~( **cab** )cbb


``` go
func lengthOfLongestSubstring(s string) int {
	m := map[byte]int{} // 哈希集合，记录每个字符出现次数
	right, res, n := -1, 0, len(s)
	for left := 0; left < n; left++ {
		if left != 0 {
			delete(m, s[left-1]) // 左指针向右移动一格，移除一个字符
		}
		for right+1 < n && m[s[right+1]] == 0 { //右指针指向字符无重复
			m[s[right+1]]++ // 不断地移动右指针
			right++
		}
		res = max(res, right-left+1) // 第 left 到 right 个字符是一个极长的无重复字符子串
	}
	return res
}
func max(x, y int) int {
	if x < y {
		return y
	}
	return x
}
```

[参考官方题解](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/227999/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/)

**方法三：双指针**

1. 思路2：
   
``` go
func lengthOfLongestSubstring(s string) int {
	m := map[rune]int{} // 记录以当前字符为终点的无重复字符最大长度
	start := 0          // 无重复字符起始下标
	res := 0            // 目前无重复字符最大长度
	for i, v := range s {
		if _, exists := m[v]; exists { // 遇到重复字符
			start = max(start, m[v]+1) // 取index较大值作为起始下标
		}
		m[v] = i                  // 无重复字符，加入m
		res = max(res, i-start+1) // 统计目前无重复字符最大长度
	}
	return res
}
func max(x, y int) int {
	if x < y {
		return y
	}
	return x
}
```

``` go
func lengthOfLongestSubstring(s string) int {
	m := map[byte]int{}
	start, res := 0, 0
	for i := 0; i < len(s); i++ {
		if _, exists := m[s[i]]; exists { // 如果出现重复字符，
			start = max(start, m[s[i]]+1) // 收缩窗口
		}
		m[s[i]] = i               // 没有出现过，加入子串，扩展移动窗口
		res = max(res, i-start+1) // 统计当前最长子串
	}
	return res
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

**方法4：位图**

``` go

```


## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) 

``` go

```

## [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

``` go

```

## [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

``` go

```

## [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

``` go

```















[补充题4. 手撕快速排序 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

