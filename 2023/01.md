

1. [3. 无重复字符的最长子串](#3-无重复字符的最长子串)
2. [206. 反转链表](#206-反转链表)
3. [146. LRU 缓存机制](#146-lru-缓存机制)
4. [215. 数组中的第K个最大元素](#215-数组中的第k个最大元素)
5. [25. K 个一组翻转链表](#25-k-个一组翻转链表)



## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)



**解法一 位图**

``` go
func lengthOfLongestSubstring(s string) int {
	if len(s) == 0 {
		return 0
	}
	var bitSet [256]bool
	result, left, right := 0, 0, 0
	for left < len(s) {
		// 右侧字符对应的 bitSet 被标记 true，说明此字符在 X 位置重复，需要左侧向前移动，直到将 X 标记为 false
		if bitSet[s[right]] {
			bitSet[s[left]] = false
			left++
		} else {
			bitSet[s[right]] = true
			right++
		}
		if result < right-left {
			result = right - left
		}
		if left+result >= len(s) || right >= len(s) {
			break
		}
	}
	return result
}
```

**解法二 滑动窗口**

``` go
func lengthOfLongestSubstring(s string) int {
	if len(s) == 0 {
		return 0
	}
	var freq [127]int
	result, left, right := 0, 0, -1
	for left < len(s) {
		if right+1 < len(s) && freq[s[right+1]] == 0 {
			freq[s[right+1]]++
			right++
		} else {
			freq[s[left]]--
			left++
		}
		if result < right-left+1 {
			result = right - left + 1
		}
	}
	return result
}
```


**解法三 滑动窗口-哈希桶**


``` go
func lengthOfLongestSubstring(s string) int {
	index := make(map[byte]int, len(s)) // 记录字符对应的下标
	result, left, right := 0, 0, 0
	for right < len(s) {
		if idx, ok := index[s[right]]; ok && idx >= left { // 遇到重复字符，跳过
			left = idx + 1 // 收缩窗口
		}
		index[s[right]] = right //首次遇见，存储对应下标
		right++                 // 指针继续向后扫描
		result = max(result, right-left)
	}
	return result
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```


**解法四 双指针 O(n)**
1. (a)bcabcbb
2. (ab)cabcbb 
3. (abc)abcbb
4. (abca)bcbb 当前字符和首字符重复
5. ~~a~~(bca)bcbb 删除首字符（收缩窗口）
6. ~~a~~(bcab)cbb 继续向后扫描（扩展窗口）
7. ~~ab~~(cab)cbb

思路：定义两个指针 i,j(i<=j)，表示当前扫描到的子串是 [i,j](闭区间)。扫描过程中维护一个哈希表 hash := map[byte]int{}，表示 [i,j]中每个字符出现的次数。线性扫描时，每次循环的流程如下：

1. 指针 j 向后移一位, 同时将哈希表中 s[j] 的计数加一: hash[s[j]]++;
2. 假设 j 移动前的区间 [i,j] 中没有重复字符，则 j 移动后，只有 s[j] 可能出现2次。因此我们不断向后移动 i，直至区间 [i,j] 中 s[j] 的个数等于1为止；
   
复杂度分析：由于 i,j 均最多增加n次，且哈希表的插入和更新操作的复杂度都是 O(1)，因此，总时间复杂度 O(n)



``` go
func lengthOfLongestSubstring(s string) int {
	hash := map[byte]int{} // 哈希集合记录每个字符出现次数
	res := 0
	for i, j := 0, 0; j < len(s); j++ {
		hash[s[j]]++                // 首次存入哈希
		for ; hash[s[j]] > 1; i++ { // 出现字符和首字符重复，i++跳过首字符(收缩窗口)
			hash[s[i]]-- // 哈希记录次数减1
		}
		if res < j-i+1 {
			res = j - i + 1 // 统计无重复字符的最长子串
		}
	}
	return res
}
```


[参考](https://www.acwing.com/solution/content/49/)


**解法五 滑动窗口**

*思路一：*

1. ( **a** )bcabcbb
2. ( **ab** )cabcbb 
3. ( **abc** )abcbb
4. ( **abca** )bcbb 当前字符和首字符重复
5. ~~a~~( **bca** )bcbb 删除首字符（收缩窗口）
6. ~~a~~( **bcab** )cbb 继续向后扫描（扩展窗口）
7. ~~ab~~( **cab** )cbb


``` go
func lengthOfLongestSubstring(s string) int {
	m := map[byte]int{} // 哈希集合，记录每个字符出现次数
	right, res, n := -1, 0, len(s)
	for left := 0; left < n; left++ {
		if left != 0 {
			delete(m, s[left-1]) // 左指针向右移动一格，移除一个字符
		}
		for right+1 < n && m[s[right+1]] == 0 { //右指针指向字符无重复
			m[s[right+1]]++ // 不断地移动右指针
			right++
		}
		res = max(res, right-left+1) // 第 left 到 right 个字符是一个极长的无重复字符子串
	}
	return res
}
func max(x, y int) int {
	if x < y {
		return y
	}
	return x
}
```

[参考官方题解](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/227999/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/)

**解法六 滑动窗口-哈希桶**

1. 思路2：
   
``` go
func lengthOfLongestSubstring(s string) int {
	m := map[rune]int{} // 记录以当前字符为终点的无重复字符最大长度
	start := 0          // 无重复字符起始下标
	res := 0            // 目前无重复字符最大长度
	for i, v := range s {
		if _, exists := m[v]; exists { // 遇到重复字符
			start = max(start, m[v]+1) // 取index较大值作为起始下标
		}
		m[v] = i                  // 无重复字符，加入m
		res = max(res, i-start+1) // 统计目前无重复字符最大长度
	}
	return res
}
func max(x, y int) int {
	if x < y {
		return y
	}
	return x
}
```

``` go
func lengthOfLongestSubstring(s string) int {
	m := map[byte]int{}
	start, res := 0, 0
	for i := 0; i < len(s); i++ {
		if _, exists := m[s[i]]; exists { // 如果出现重复字符，
			start = max(start, m[s[i]]+1) // 收缩窗口
		}
		m[s[i]] = i               // 没有出现过，加入子串，扩展移动窗口
		res = max(res, i-start+1) // 统计当前最长子串
	}
	return res
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```



## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) 

**方法一：迭代**

假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。

在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。


``` go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
	var prev *ListNode // prev -> nil
	curr := head
	for curr != nil { // 当前节点不为空
		next := curr.Next // 存储后续节点
		curr.Next = prev  // 反转
		prev = curr       // 迭代扫描下一对
		curr = next
	}
	return prev
}
```

**复杂度分析**

- 时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。

- 空间复杂度：O(1)。



**方法二：递归**

``` go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil { // 最小子问题：无 / 只有一个节点
		return head
	}
	newHead := reverseList(head.Next) // 递：1->2->3->4->5->nil
	head.Next.Next = head             // 归：5->4   (1->2->3->  4->5->nil)
	head.Next = nil                   //    4->nil
	return newHead
}
```

**方法三：头插法**

``` go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	dummy, curr := &ListNode{Next: head}, head
	for curr.Next != nil {
		next := curr.Next
		curr.Next = next.Next  //后继结点 1——>3
		next.Next = dummy.Next //反转 2->1
		dummy.Next = next      //通知哨兵 dummy-> 2->1->3
	}
	return dummy.Next
}
```



## [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

``` go
/*
 * @lc app=leetcode.cn id=146 lang=golang
 *
 * [146] LRU 缓存
 */

// @lc code=start
type LRUCache struct {
	cache          map[int]*DLinkedNode
	head, tail     *DLinkedNode
	size, capacity int // 忘记 int ❌
}

type DLinkedNode struct { // 多写() ❌
	key, value int
	prev, next *DLinkedNode
}

func initDLinkedNode(key, value int) *DLinkedNode {
	return &DLinkedNode{
		key:   key,
		value: value,
	}
}

func Constructor(capacity int) LRUCache {
	l := LRUCache{
		cache:    map[int]*DLinkedNode{},
		head:     initDLinkedNode(0, 0),
		tail:     initDLinkedNode(0, 0),
		capacity: capacity,
	}
	l.head.next = l.tail
	l.tail.prev = l.head
	return l
}

func (this *LRUCache) Get(key int) int {
	if _, ok := this.cache[key]; !ok {
		return -1
	} else {
		node := this.cache[key]
		// this.addToHead(node) 错误❌
		this.moveToHead(node)
		return node.value
	}
}

func (this *LRUCache) Put(key int, value int) {
	if _, ok := this.cache[key]; !ok {
		node := initDLinkedNode(key, value)
		this.cache[key] = node
		this.addToHead(node) // 缺少操作❌     缺少this❌
		this.size++
		if this.size > this.capacity {
			node := this.removeTail()
			delete(this.cache, node.key)
			this.size--
		}

	} else {
		node := this.cache[key]
		node.value = value // node.key = value ❌
		this.moveToHead(node)
	}
}

// 双链表操作

func (this *LRUCache) addToHead(node *DLinkedNode) {
	node.prev = this.head      // 寻找前驱节点
	node.next = this.head.next // 寻找后继节点
	node.next.prev = node
	this.head.next = node
}

func (this *LRUCache) removeNode(node *DLinkedNode) {
	node.prev.next = node.next
	node.next.prev = node.prev
}

func (this *LRUCache) moveToHead(node *DLinkedNode) {
	this.removeNode(node) // 拼写错误 removedNode ❌
	this.addToHead(node)
}

func (this *LRUCache) removeTail() *DLinkedNode {
	node := this.tail.prev
	this.removeNode(node)
	return node
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
// @lc code=end


```

## [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

``` go

```

## [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

``` go

```















[补充题4. 手撕快速排序 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

