

1. [122. 买卖股票的最佳时机 II](#122-买卖股票的最佳时机-ii)
2. [198. 打家劫舍](#198-打家劫舍)
3. [152. 乘积最大子数组](#152-乘积最大子数组)
4. [662. 二叉树最大宽度](#662-二叉树最大宽度)
5. [179. 最大数](#179-最大数)
6. [24. 两两交换链表中的节点](#24-两两交换链表中的节点)
7. [283. 移动零 --\>](#283-移动零---)
8. [138. 复制带随机指针的链表](#138-复制带随机指针的链表)
9. [153. 寻找旋转排序数组中的最小值](#153-寻找旋转排序数组中的最小值)
10. [139. 单词拆分](#139-单词拆分)


## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```go
func maxProfit(prices []int) int {
	protit := 0
	for i := 0; i < len(prices)-1; i++ {
		if prices[i+1] > prices[i] {
			protit += prices[i+1] - prices[i]
		}
	}
	return protit
}
```

## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

```go
func rob(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	if n == 1 {
		return nums[0]
	}
	dp := make([]int, n)
	dp[0] = nums[0]               // 只有一间房屋，则偷窃该房屋
	dp[1] = max(nums[0], nums[1]) // 只有两间房屋，选择其中金额较高的房屋进行偷窃
	for i := 2; i < n; i++ {
		dp[i] = max(dp[i-2]+nums[i], dp[i-1]) // dp[i] 前i间房屋能偷窃到的最高总金额 = max(抢第i间房子，不抢第i件房子)
	}
	return dp[n-1]
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

```go
func rob(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	pre1, pre2 := 0, 0
	for i := 0; i < n; i++ {
		tmp := pre1
		pre1 = max(pre2+nums[i], pre1)
		pre2 = tmp
	}
	return pre1
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```


```go
func rob(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	preMax, curMax := 0, 0
	for i := 0; i < n; i++ {
		// preMax, curMax = curMax, max(preMax+nums[i], curMax)
		tmp := curMax
		curMax = max(preMax+nums[i], curMax)
		preMax = tmp
	}
	return curMax
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```





## [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

```go
func maxProduct(nums []int) int {
	maxF, minF, res := nums[0], nums[0], nums[0]
	for i := 1; i < len(nums); i++ {
		if nums[i] < 0 { // 如果 nums[i] 是负数
			maxF, minF = minF, maxF // 交换最大值与最小值
		}
		maxF = max(nums[i], maxF*nums[i])
		minF = min(nums[i], minF*nums[i])
		res = max(res, maxF)
	}
	return res
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}
```

```go
func maxProduct(nums []int) int {
	maxF, minF, res := nums[0], nums[0], nums[0]
	for i := 1; i < len(nums); i++ {
		mx, mn := maxF, minF
		maxF = max(mx*nums[i], max(mn*nums[i], nums[i]))
		minF = min(mn*nums[i], min(mx*nums[i], nums[i]))
		res = max(res, maxF)
	}
	return res
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}
```

## [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)


## [179. 最大数](https://leetcode-cn.com/problems/largest-number/)


## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)


## [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/) -->


## [138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)

## [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)


## [139. 单词拆分](https://leetcode.cn/problems/word-break/)




