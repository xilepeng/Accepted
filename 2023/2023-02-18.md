

1. [122. 买卖股票的最佳时机 II](#122-买卖股票的最佳时机-ii)
2. [198. 打家劫舍](#198-打家劫舍)
3. [152. 乘积最大子数组](#152-乘积最大子数组)
4. [662. 二叉树最大宽度](#662-二叉树最大宽度)
5. [179. 最大数](#179-最大数)
6. [24. 两两交换链表中的节点](#24-两两交换链表中的节点)
7. [283. 移动零 --\>](#283-移动零---)
8. [138. 复制带随机指针的链表](#138-复制带随机指针的链表)
9. [153. 寻找旋转排序数组中的最小值](#153-寻找旋转排序数组中的最小值)
10. [139. 单词拆分](#139-单词拆分)


## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```go
func maxProfit(prices []int) int {
	protit := 0
	for i := 0; i < len(prices)-1; i++ {
		if prices[i+1] > prices[i] {
			protit += prices[i+1] - prices[i]
		}
	}
	return protit
}
```

## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

```go
func rob(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	if n == 1 {
		return nums[0]
	}
	dp := make([]int, n)
	dp[0] = nums[0]               // 只有一间房屋，则偷窃该房屋
	dp[1] = max(nums[0], nums[1]) // 只有两间房屋，选择其中金额较高的房屋进行偷窃
	for i := 2; i < n; i++ {
		dp[i] = max(dp[i-2]+nums[i], dp[i-1]) // dp[i] 前i间房屋能偷窃到的最高总金额 = max(抢第i间房子，不抢第i件房子)
	}
	return dp[n-1]
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

```go
func rob(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	pre1, pre2 := 0, 0
	for i := 0; i < n; i++ {
		tmp := pre1
		pre1 = max(pre2+nums[i], pre1)
		pre2 = tmp
	}
	return pre1
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```


```go
func rob(nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	preMax, curMax := 0, 0
	for i := 0; i < n; i++ {
		// preMax, curMax = curMax, max(preMax+nums[i], curMax)
		tmp := curMax
		curMax = max(preMax+nums[i], curMax)
		preMax = tmp
	}
	return curMax
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```


```go
// 解法三 模拟
func rob(nums []int) int {
	// a 对于偶数位上的最大值的记录
	// b 对于奇数位上的最大值的记录
	a, b := 0, 0
	for i := 0; i < len(nums); i++ {
		if i%2 == 0 {
			a = max(a+nums[i], b)
		} else {
			b = max(b+nums[i], a)
		}
	}
	return max(a, b)
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```


## [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

```go
func maxProduct(nums []int) int {
	maxF, minF, res := nums[0], nums[0], nums[0]
	for i := 1; i < len(nums); i++ {
		if nums[i] < 0 { // 如果 nums[i] 是负数
			maxF, minF = minF, maxF // 交换最大值与最小值
		}
		maxF = max(nums[i], maxF*nums[i])
		minF = min(nums[i], minF*nums[i])
		res = max(res, maxF)
	}
	return res
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}
```

```go
func maxProduct(nums []int) int {
	maxF, minF, res := nums[0], nums[0], nums[0]
	for i := 1; i < len(nums); i++ {
		mx, mn := maxF, minF
		maxF = max(mx*nums[i], max(mn*nums[i], nums[i]))
		minF = min(mn*nums[i], min(mx*nums[i], nums[i]))
		res = max(res, maxF)
	}
	return res
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}
```




## [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)



## [179. 最大数](https://leetcode-cn.com/problems/largest-number/)
```go
func largestNumber(nums []int) string {
	if len(nums) == 0 {
		return ""
	}
	res := ""
	s := numToString(nums)
	quickSortString(s, 0, len(s)-1)
	for _, str := range s {
		if res == "0" && str == "0" {
			continue
		}
		res += str
	}
	return res
}

func numToString(nums []int) []string {
	s := make([]string, 0)
	for i := 0; i < len(nums); i++ {
		s = append(s, strconv.Itoa(nums[i]))
	}
	return s
}

func quickSortString(s []string, start, end int) {
	if start <= end {
		piv_pos := partition(s, start, end)
		quickSortString(s, start, piv_pos-1)
		quickSortString(s, piv_pos+1, end)
	}
}

func partition(s []string, start, end int) int {
	i, x := start, s[end]
	for j := start; j < end; j++ {
		sjx, xsj := s[j]+x, x+s[j]
		if sjx > xsj {
			s[i], s[j] = s[j], s[i]
			i++
		}
	}
	s[i], s[end] = s[end], s[i]
	return i
}
```

## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)


## [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/) -->


## [138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)

## [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

```go
func findMin(nums []int) int {
	low, high := 0, len(nums)-1
	for low < high {
		mid := low + (high-low)>>1
		if nums[mid] < nums[high] {
			high = mid // 答案在 [0,mid]
		} else {
			low = mid + 1 // 答案在 [mid+1,high]
		}
	}
	return nums[low]
}
```


## [560. 和为K的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)






