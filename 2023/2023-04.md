
1. [124. 二叉树中的最大路径和](#124-二叉树中的最大路径和)
2. [19. 删除链表的倒数第N个节点](#19-删除链表的倒数第n个节点)
3. [94. 二叉树的中序遍历](#94-二叉树的中序遍历)
4. [72. 编辑距离](#72-编辑距离)
5. [704. 二分查找](#704-二分查找)
6. [4. 寻找两个正序数组的中位数](#4-寻找两个正序数组的中位数)
7. [232. 用栈实现队列](#232-用栈实现队列)
8. [199. 二叉树的右视图](#199-二叉树的右视图)
9. [70. 爬楼梯](#70-爬楼梯)
10. [56. 合并区间](#56-合并区间)


## [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxPathSum(root *TreeNode) int {
	maxSum := math.MinInt32
	var maxGain func(*TreeNode) int

	maxGain = func(node *TreeNode) int {
		if node == nil {
			return 0
		}
		// 只有在最大贡献值大于 0 时，才会选取对应子节点
		left := max(maxGain(node.Left), 0)
		right := max(maxGain(node.Right), 0)
		// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
		currPathSum := left + node.Val + right
		maxSum = max(maxSum, currPathSum)  // 更新答案
		return node.Val + max(left, right) // 返回节点的最大贡献值
	}

	maxGain(root)
	return maxSum
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

## [19. 删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummy := &ListNode{-1, head}
	first, second := head, dummy
	for i := 0; i < n; i++ {
		first = first.Next // 1. 快指针先走n步
	}
	for ; first != nil; first = first.Next {
		second = second.Next // 2. 快慢指针同时走到头，找到要删除节点的前一个节点
	}
	second.Next = second.Next.Next // 3. 删除
	return dummy.Next
}
```

## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) (res []int) {
	var inorder func(*TreeNode)
	inorder = func(node *TreeNode) {
		if node == nil {
			return
		}
		inorder(node.Left)
		res = append(res, node.Val)
		inorder(node.Right)
	}
	inorder(root)
	return
}
```
## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)


## [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

```go
func search(nums []int, target int) int {
	left, right := 0, len(nums)-1
	for left <= right {
		mid := left + (right-left)>>1
		if nums[mid] == target {
			return mid
		} else if nums[mid] < target {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return -1
}
```

## [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)


## [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)


## [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```go

```

## [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)
