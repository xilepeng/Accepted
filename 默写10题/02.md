

1. [141. 环形链表](#141-环形链表)
2. [102. 二叉树的层序遍历](#102-二叉树的层序遍历)
3. [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
4. [160. 相交链表](#160-相交链表)
5. [88. 合并两个有序数组](#88-合并两个有序数组)
6. [103. 二叉树的锯齿形层序遍历](#103-二叉树的锯齿形层序遍历)
7. [20. 有效的括号](#20-有效的括号)
8. [236. 二叉树的最近公共祖先](#236-二叉树的最近公共祖先)
9. [5. 最长回文子串](#5-最长回文子串)
10. [415. 字符串相加](#415-字符串相加)



## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
	if head == nil || head.Next == nil {
		return false
	}
	slow, fast := head, head.Next
	for slow != fast {
		if fast == nil || fast.Next == nil { // 快指针跑到终点 没遇到慢指针
			return false // 没找到环
		}
		slow = slow.Next
		fast = fast.Next.Next
	}
	return true
}
```

## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
	res := [][]int{}
	var dfs func(*TreeNode, int)
	dfs = func(node *TreeNode, level int) {
		if node == nil {
			return
		}
		if len(res) == level {
			res = append(res, []int{})
		}
		res[level] = append(res[level], node.Val)
		dfs(node.Left, level+1) // 下一层 level++
		dfs(node.Right, level+1)
	}
	dfs(root, 0)
	return res
}
```

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
	res := [][]int{}
	if root == nil {
		return res
	}
	queue := []*TreeNode{root} // 队列记录当前层所有节点
	for level := 0; 0 < len(queue); level++ { // 遍历下一层节点
		res = append(res, []int{})
		next := []*TreeNode{}
		for _, node := range queue {
			res[level] = append(res[level], node.Val) // 当前层节点出队
			if node.Left != nil {  // 下一层不为空
				next = append(next, node.Left) // 下一层节点入队
			}
			if node.Right != nil { // 下一层不为空
				next = append(next, node.Right) // 下一层节点入队
			}
		}
		queue = next // 下一层入队
	}
	return res
}
```

## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)


```go
func maxProfit(prices []int) int {
	min_price, max_profit := math.MaxInt64, 0
	for _, price := range prices {
		if price < min_price { // 最低价格买入
			min_price = price
		} else if max_profit < price-min_price { // 最高利润卖出
			max_profit = price - min_price
		}
	}
	return max_profit
}
```



```go
func maxProfit(prices []int) int {
	T_i10 := 0             // 第 i 天结束时的最大利润，最多有1笔交易，采取行动后我们手中有0只股票
	T_i11 := math.MinInt64 // 第 i 天结束时最多有1笔交易的最大利润，并在采取行动后我们手中有1只股票。
	for _, price := range prices {
		// T_i10，我们只需要决定哪种行动能带来更高的利润，休息还是出售。
		// 如果采取行动出售，我们购买股票的价格是T_i11，即第i日之前的最低价值。
		T_i10 = max(T_i10, T_i11+price)
		// T_i11实际上只是代表截至第i天所有股价负值的最大值，或相当于所有股价的最低值。
		T_i11 = max(T_i11, -price)
	}
	return T_i10
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```


```go
func maxProfit(prices []int) int {
	buy := math.MinInt64 // buy 买入之后的余额
	sell := 0            // sell 卖出之后的余额
	for _, price := range prices {
		buy = max(buy, -price)
		sell = max(sell, buy+price) // (买入之后的余额 + 卖出价格)
	}
	return sell
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```



[参考](https://www.bilibili.com/video/BV1hQ4y1R7pL)



```go
func maxProfit(prices []int) int {
	min_price, max_profit := math.MaxInt64, 0
	for _, price := range prices {
		min_price = min(min_price, price) // 最低价格买入
		max_profit = max(max_profit, price-min_price) // 最高利润卖出
	}
	return max_profit
}
func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```





## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	if headA == nil || headB == nil {
		return nil
	}
	A, B := headA, headB
	for A != B {
		if A != nil {
			A = A.Next
		} else {
			A = headB
		}
		if B != nil {
			B = B.Next
		} else {
			B = headA
		}
	}
	return A
}
```


## [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)


```go
func merge(nums1 []int, m int, nums2 []int, n int) {
	i, j := m-1, n-1
	for tail := m + n - 1; tail >= 0; tail-- {
		if j < 0 || (i >= 0 && nums1[i] > nums2[j]) { // nums2结束 或 nums1没结束
			nums1[tail] = nums1[i]
			i--
		} else { // nums1 nums2 都没结束
			nums1[tail] = nums2[j]
			j--
		}
	}
}
```


```go
func merge(nums1 []int, m int, nums2 []int, n int) {
	copy(nums1[m:], nums2)
	sort.Ints(nums1)
}
```


## [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)


```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func zigzagLevelOrder(root *TreeNode) [][]int {
	res := [][]int{}
	var dfs func(*TreeNode, int)
	dfs = func(node *TreeNode, level int) {
		if node == nil {
			return
		}
		if level == len(res) {
			res = append(res, []int{})
		}
		if level%2 == 0 { // 偶数层 从左往右 遍历
			res[level] = append(res[level], node.Val)
		} else { // 奇数层 从右往左 遍历
			res[level] = append([]int{node.Val}, res[level]...)
		}
		dfs(node.Left, level+1)
		dfs(node.Right, level+1)
	}
	dfs(root, 0)
	return res
}
```

## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```go

```

## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```go

```

## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```go

```

## [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)


```go

```