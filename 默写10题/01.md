


1. [✅ 206. 反转链表](#-206-反转链表)
2. [✅ 146. LRU 缓存机制](#-146-lru-缓存机制)
3. [✅ 3. 无重复字符的最长子串](#-3-无重复字符的最长子串)
4. [✅ 215. 数组中的第K个最大元素](#-215-数组中的第k个最大元素)
5. [❌ ✅ 25. K 个一组翻转链表](#--25-k-个一组翻转链表)
6. [✅ 补充题4. 手撕快速排序 912. 排序数组](#-补充题4-手撕快速排序-912-排序数组)
7. [✅ 15. 三数之和](#-15-三数之和)
8. [✅ 53. 最大子序和](#-53-最大子序和)
9. [✅ 1. 两数之和](#-1-两数之和)
10. [✅ 21. 合并两个有序链表](#-21-合并两个有序链表)




## ✅ [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) 

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	dummy, curr := &ListNode{Next: head}, head
	for curr.Next != nil {
		next := curr.Next
		curr.Next = next.Next
		next.Next = dummy.Next
		dummy.Next = next
	}
	return dummy.Next
}
```

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	newHead := reverseList(head.Next) // 递：找到最小子问题
	head.Next.Next = head             // 归：反转
	head.Next = nil                   // 断开之前连接
	return newHead
}
```

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
	var prev *ListNode //prev -> nil
	curr := head
	for curr != nil {	  //当前节点不为空
		next := curr.Next //1.存储下一个节点
		curr.Next = prev  //2.当前节点的next指针指向前一个节点
		prev = curr       //3.移动双指针
		curr = next
	}
	return prev
}
```

## ✅ [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

```go
type LRUCache struct {
	cache          map[int]*DLinkedList
	head, tail     *DLinkedList
	size, capacity int
}

type DLinkedList struct {
	key, value int
	prev, next *DLinkedList
}

func initDLinkedList(key, value int) *DLinkedList {
	return &DLinkedList{
		key:   key,
		value: value,
	}
}

func Constructor(capacity int) LRUCache {
	l := LRUCache{
		cache:    map[int]*DLinkedList{},
		head:     initDLinkedList(0, 0),
		tail:     initDLinkedList(0, 0),
		capacity: capacity,
		size:     0,
	}
	l.head.next = l.tail
	l.tail.prev = l.head
	return l
}

func (this *LRUCache) Get(key int) int {
	if _, ok := this.cache[key]; !ok {
		return -1
	}
	node := this.cache[key]
	this.moveToHead(node)
	return node.value
}

func (this *LRUCache) Put(key int, value int) {
	if _, ok := this.cache[key]; !ok {
		node := initDLinkedList(key, value)
		this.cache[key] = node
		this.addToHead(node)
		this.size++
		for this.size > this.capacity {
			removed := this.removeTail()
			delete(this.cache, removed.key)
			this.size--
		}
	} else {
		node := this.cache[key]
		node.value = value
		this.moveToHead(node)
	}
}

func (this *LRUCache) moveToHead(node *DLinkedList) {
	this.removeNode(node)
	this.addToHead(node)
}

func (this *LRUCache) removeNode(node *DLinkedList) {
	node.prev.next = node.next
	node.next.prev = node.prev
}

func (this *LRUCache) addToHead(node *DLinkedList) {
	node.prev = this.head
	node.next = this.head.next
	this.head.next.prev = node
	this.head.next = node
}

func (this *LRUCache) removeTail() *DLinkedList {
	node := this.tail.prev
	this.removeNode(node)
	return node
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
```

## ✅ [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)


```go
func lengthOfLongestSubstring(s string) int {
	hash := map[rune]int{}
	start, res := 0, 0
	for i, ch := range s {
		if _, ok := hash[ch]; ok {
			start = max(start, hash[ch]+1)
		}
		hash[ch] = i
		res = max(res, i-start+1)
	}
	return res
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```

```go
func lengthOfLongestSubstring(s string) int {
	m := map[byte]int{}
	start, res := 0, 0
	for i := 0; i < len(s); i++ {
		if _, ok := m[s[i]]; ok { // 有重复
			start = max(start, m[s[i]]+1) // 取重复复字符的最大下标
		}
		m[s[i]] = i               // 无重复，加入map
		res = max(res, i-start+1) // 当前无重复字符的最长子串
	}
	return res
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}
```




## ✅ [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

```go
func findKthLargest(nums []int, k int) int {
	return quick_select(nums, 0, len(nums)-1, len(nums)-k)
}

func quick_select(A []int, start, end, i int) int {
	if piv_pos := partition(A, start, end); piv_pos == i {
		return A[i]
	} else if piv_pos < i {
		return quick_select(A, piv_pos+1, end, i)
	} else {
		return quick_select(A, start, piv_pos-1, i)
	}
}

func partition(A []int, start, end int) int {
	piv, i := A[start], start+1
	for j := start + 1; j <= end; j++ {
		if A[j] < piv {
			A[i], A[j] = A[j], A[i]
			i++
		}
	}
	A[start], A[i-1] = A[i-1], A[start]
	return i - 1
}
```

## ❌ ✅ [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
	dummy := &ListNode{Next: head}
	prev := dummy
	for head != nil {
		tail := prev
		for i := 0; i < k; i++ {
			tail = tail.Next
			if tail == nil { // 易漏
				return dummy.Next
			}
		}
		succ := tail.Next //存储后继
		tail.Next = nil
		prev.Next = reverse(head)
		head.Next = succ // 连接后继
		prev = head      // 查看下一组
		head = succ
	}
	return dummy.Next
}

func reverse(head *ListNode) *ListNode {
	var prev *ListNode
	curr := head
	for curr != nil {
		next := curr.Next
		curr.Next = prev
		prev = curr
		curr = next
	}
	return prev
}
```

## ✅ [补充题4. 手撕快速排序 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```go
func sortArray(nums []int) []int {
	quick_sort(nums, 0, len(nums)-1)
	return nums
}

func quick_sort(A []int, start, end int) {
	if start < end {
		piv_pos := partition(A, start, end)
		quick_sort(A, start, piv_pos-1)
		quick_sort(A, piv_pos+1, end)
	}
}

func partition(A []int, start, end int) int {
	piv, i := A[start], start+1
	for j := start + 1; j <= end; j++ {
		if A[j] < piv {
			A[i], A[j] = A[j], A[i]
			i++
		}
	}
	A[start], A[i-1] = A[i-1], A[start]
	return i - 1
}
```




## ✅ [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```go
func threeSum(nums []int) [][]int {
	res := [][]int{}
	sort.Ints(nums)
	for i := 0; i < len(nums)-2; i++ {
		n1 := nums[i]
		if n1 > 0 {
			break
		}
		if i > 0 && n1 == nums[i-1] {  // 易错
			continue
		}
		l, r := i+1, len(nums)-1
		for l < r {
			n2, n3 := nums[l], nums[r]
			if n1+n2+n3 == 0 {
				res = append(res, []int{n1, n2, n3})
				for l < r && n2 == nums[l] {  // 易错
					l++
				}
				for l < r && n3 == nums[r] {
					r--
				}
			} else if n1+n2+n3 < 0 {
				l++
			} else {
				r--
			}
		}
	}
	return res
}
```

## ✅ [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

```go
func maxSubArray(nums []int) int {
	max := nums[0]  // 易错 
	for i := 1; i < len(nums); i++ {
		if nums[i-1]+nums[i] > nums[i] {
			nums[i] += nums[i-1]
		}
		if nums[i] > max {
			max = nums[i]
		}
	}
	return max
}
```





## ✅ [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

```go
func twoSum(nums []int, target int) []int {
	m := map[int]int{} // 易错 [int]int{}   []int{}
	for i, v := range nums {
		if j, ok := m[target-v]; ok {
			return []int{i, j}
		}
		m[v] = i
	}
	return []int{}
}
```

## ✅ [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}
	if l1.Val < l2.Val {
		l1.Next = mergeTwoLists(l1.Next, l2)
		return l1
	} else {// 易错 if 会导致逻辑错误❌
		l2.Next = mergeTwoLists(l1, l2.Next)
		return l2
	}
}
```


```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	dummy := &ListNode{}
	curr := dummy
	for l1 != nil && l2 != nil {
		if l1.Val < l2.Val {
			curr.Next = l1
			l1 = l1.Next
		} else {
			curr.Next = l2
			l2 = l2.Next
		}
		curr = curr.Next
	}
	if l1 != nil {
		curr.Next = l1
	} else {
		curr.Next = l2
	}
	return dummy.Next
}
```