

1. [🚀 206. 反转链表](#-206-反转链表)
2. [✅ 146. LRU 缓存机制](#-146-lru-缓存机制)
3. [❌3. 无重复字符的最长子串](#3-无重复字符的最长子串)
4. [❓ 215. 数组中的第K个最大元素](#-215-数组中的第k个最大元素)
5. [25. K 个一组翻转链表](#25-k-个一组翻转链表)
6. [补充题4. 手撕快速排序 912. 排序数组](#补充题4-手撕快速排序-912-排序数组)
7. [15. 三数之和](#15-三数之和)
8. [53. 最大子序和](#53-最大子序和)
9. [1. 两数之和](#1-两数之和)
10. [21. 合并两个有序链表](#21-合并两个有序链表)



<!-- [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) 

[146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

[补充题4. 手撕快速排序 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) -->





## 🚀 [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) 

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode 
    curr := head
    for curr != nil {
        next := curr.Next 
        curr.Next = prev
        prev = curr 
        curr = next
    }
    return prev
}
```





## ✅ [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)


```go
type LRUCache struct {
	cache          map[int]*DLinkedNode // 忘写 map
	head, tail     *DLinkedNode
	size, capacity int // 忘写 size
}

type DLinkedNode struct {
	key, value int
	prev, next *DLinkedNode
}

func initDLinkedNode(key, value int) *DLinkedNode {
	return &DLinkedNode{
		key:   key, // 忘写,
		value: value,
	}
}

func Constructor(capacity int) LRUCache {
	l := LRUCache{
		cache:    map[int]*DLinkedNode{}, // 忘记初始化 cache
		capacity: capacity,
		head:     initDLinkedNode(0, 0),
		tail:     initDLinkedNode(0, 0),
	}
	l.head.next = l.tail
	l.tail.prev = l.head
	return l
}

func (this *LRUCache) Get(key int) int {
	if _, exists := this.cache[key]; !exists { // 忘记 this
		return -1
	}
	node := this.cache[key]
	this.moveToHead(node)
	return node.value
}

func (this *LRUCache) Put(key int, value int) {
	if _, exists := this.cache[key]; !exists {
		node := initDLinkedNode(key, value)
		this.cache[key] = node
		this.addToHead(node) //忘记写，导致 removeNode(nil)
		this.size++
		for this.size > this.capacity {
			remove := this.removeTail()
			this.size--
			delete(this.cache, remove.key) // 语法格式写错
		}
	} else {
		node := this.cache[key]
		node.value = value
		this.moveToHead(node)
	}
}

func (this *LRUCache) moveToHead(node *DLinkedNode) {
	this.removeNode(node)
	this.addToHead(node)
}

func (this *LRUCache) removeNode(node *DLinkedNode) {
	node.prev.next = node.next
	node.next.prev = node.prev
}

func (this *LRUCache) addToHead(node *DLinkedNode) {
	node.prev = this.head
	node.next = this.head.next
	this.head.next.prev = node
	this.head.next = node
}

func (this *LRUCache) removeTail() *DLinkedNode {
	node := this.tail.prev
	this.removeNode(node)
	return node
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */

```

## ❌[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```go

```

[参考](https://www.bilibili.com/video/BV1ub4y1d7Z8)

## ❓ [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)


```go
func findKthLargest(nums []int, k int) int {
	rand.Seed(time.Now().UnixNano()) // 写错
	return quickSelect(nums, 0, len(nums)-1, len(nums)-k)
}

func quickSelect(nums []int, start, end, i int) int {
	if piv_pos := randomPartition(nums, start, end); piv_pos == i {
		return nums[piv_pos]
	} else if piv_pos < i {
		return quickSelect(nums, piv_pos+1, end, i) // 忘记 return
	} else {
		return quickSelect(nums, start, piv_pos-1, i)
	}
}

func randomPartition(A []int, start, end int) int {
	random := start + rand.Int()%(end-start+1)
	A[start], A[random] = A[random], A[start] // 不是A[0]
	return partition(A, start, end)
}

func partition(A []int, start, end int) int {
	piv, i := A[start], start+1
	for j := start; j <= end; j++ {
		if A[j] < piv { // 写错 保证 A[i] < piv < A[j]
			A[i], A[j] = A[j], A[i]
			i++
		}
	}
	A[start], A[i-1] = A[i-1], A[start]
	return i - 1
}
```


## [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)


```go

```

## [补充题4. 手撕快速排序 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```go

```

## [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```go
func threeSum(nums []int) [][]int {
	sort.Ints(nums) // nums = [-4,-1,-1,0,1,2]
	res := make([][]int, 0)
	for i := 0; i < len(nums)-2; i++ {
		n1 := nums[i]
		if n1 > 0 { // 最小数 > 0 肯定不满足等于0的条件
			break
		}
		if i > 0 && n1 == nums[i-1] { // 去重
			continue
		}
		l, r := i+1, len(nums)-1
		for l < r {
			n2, n3 := nums[l], nums[r]
			if n1+n2+n3 == 0 {
				res = append(res, []int{n1, n2, n3})
				for l < r && n2 == nums[l] { // n2 重复
					l++ // 跳过
				}
				for l < r && n3 == nums[r] { // n3 重复
					r-- // 跳过
				}
			} else if n1+n2+n3 < 0 {
				l++
			} else {
				r--
			}
		}
	}
	return res
}
```

## [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

## [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

## [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

